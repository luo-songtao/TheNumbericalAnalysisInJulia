<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>用于对称正定矩阵的方法 · 数值分析(Julia语言描述)</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/logo.png" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="数值分析(Julia语言描述) logo"/></a><div class="docs-package-name"><span class="docs-autofit">数值分析(Julia语言描述)</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">求解一元方程</span><ul><li><a class="tocitem" href="../../equation_solving/">目录</a></li><li><a class="tocitem" href="../../equation_solving/bisect/">二分法</a></li><li><a class="tocitem" href="../../equation_solving/fixed_point_iteration/">不动点迭代法</a></li><li><a class="tocitem" href="../../equation_solving/newton_method/">牛顿方法</a></li><li><a class="tocitem" href="../../equation_solving/secant/">割线方法</a></li></ul></li><li><span class="tocitem">求解n元方程组</span><ul><li><a class="tocitem" href="../">目录</a></li><li><a class="tocitem" href="../gauss_elimination/">高斯消去法</a></li><li><a class="tocitem" href="../lu_factorization/">LU分解</a></li><li><a class="tocitem" href="../iteration_method/">迭代方法</a></li><li class="is-active"><a class="tocitem" href>用于对称正定矩阵的方法</a><ul class="internal"><li><a class="tocitem" href="#楚列斯基分解法-1"><span>楚列斯基分解法</span></a></li><li><a class="tocitem" href="#共轭梯度方法-1"><span>共轭梯度方法</span></a></li><li><a class="tocitem" href="#预条件共轭梯度方法-1"><span>预条件共轭梯度方法</span></a></li><li><a class="tocitem" href="#使用对称连续过松弛(SSOR)预条件子的共轭梯度法-1"><span>使用对称连续过松弛(SSOR)预条件子的共轭梯度法</span></a></li></ul></li><li><a class="tocitem" href="../nonlinear_equation_set/">非线性方程组</a></li></ul></li><li><span class="tocitem">插值多项式</span><ul><li><a class="tocitem" href="../../interpolation_polynomial/">目录</a></li><li><a class="tocitem" href="../../interpolation_polynomial/newton_difference_quotient/">牛顿差商</a></li></ul></li><li><a class="tocitem" href="../../polyomial/">多项式求值</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">求解n元方程组</a></li><li class="is-active"><a href>用于对称正定矩阵的方法</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>用于对称正定矩阵的方法</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/luo-songtao/TheNumbericalAnalysisInJulia/blob/master/docs/src/numberical_analysis/equation_set/methods_about_SPD_matrix.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="用于对称正定矩阵的方法-1"><a class="docs-heading-anchor" href="#用于对称正定矩阵的方法-1">用于对称正定矩阵的方法</a><a class="docs-heading-anchor-permalink" href="#用于对称正定矩阵的方法-1" title="Permalink"></a></h1><ul><li><a href="#EquationSet.cholesky_decomposition-Tuple{Any,Any}"><code>EquationSet.cholesky_decomposition</code></a></li><li><a href="#EquationSet.conjugate_gradient-NTuple{4,Any}"><code>EquationSet.conjugate_gradient</code></a></li><li><a href="#EquationSet.conjugate_gradient_with_pre_condition-NTuple{5,Any}"><code>EquationSet.conjugate_gradient_with_pre_condition</code></a></li><li><a href="#EquationSet.ssor"><code>EquationSet.ssor</code></a></li></ul><h2 id="楚列斯基分解法-1"><a class="docs-heading-anchor" href="#楚列斯基分解法-1">楚列斯基分解法</a><a class="docs-heading-anchor-permalink" href="#楚列斯基分解法-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationSet.cholesky_decomposition-Tuple{Any,Any}" href="#EquationSet.cholesky_decomposition-Tuple{Any,Any}"><code>EquationSet.cholesky_decomposition</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>楚列斯基分解</strong></p><pre><code class="language-none">cholesky_decomposition(A, n)</code></pre><p><strong>楚列斯基分解定理</strong>：<span>$A$</span>是<span>$n \times n$</span>对称正定矩阵，则存在上三角矩阵<span>$R$</span>满足<span>$A=R^TR$</span></p><p><span>$A = \left [ \begin{matrix} a &amp; b \\ b &amp; c \end{matrix} \right ] = \left [ \begin{matrix} \sqrt{a} &amp; 0 \\ \frac{b}{\sqrt{a}} &amp; \sqrt{c-b^2/a} \end{matrix} \right ] \left [ \begin{matrix} \sqrt{a} &amp; \frac{b}{\sqrt{a}} \\ 0 &amp; \sqrt{c-b^2/a} \end{matrix} \right ]=R^TR$</span></p><p>对于对称正定矩阵<span>$A$</span>，求解<span>$Ax=b$</span>，和<span>$LU$</span>分解方式相同：</p><p><span>$R^Tc=b \Longrightarrow c \\ Rx=c \Longrightarrow x$</span></p><p>这样针对对称正定矩阵的方程组求解，等于降低了一般的计算代价来实现。</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = Float64[4 -2 2;-2 2 -4; 2 -4 11]
3×3 Array{Float64,2}:
  4.0  -2.0   2.0
 -2.0   2.0  -4.0
  2.0  -4.0  11.0
julia&gt; R = cholesky_decomposition(A, 3)
3×3 Array{Float64,2}:
 2.0  -1.0   1.0
 0.0   1.0  -3.0
 0.0   0.0   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumbericalAnalysisInJulia/blob/7219ea58de8b789c9f80319e3c3195c5e701b832/src/equation_set/cholesky_decomposition.jl#L2-L29">source</a></section></article><h2 id="共轭梯度方法-1"><a class="docs-heading-anchor" href="#共轭梯度方法-1">共轭梯度方法</a><a class="docs-heading-anchor-permalink" href="#共轭梯度方法-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationSet.conjugate_gradient-NTuple{4,Any}" href="#EquationSet.conjugate_gradient-NTuple{4,Any}"><code>EquationSet.conjugate_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>共轭梯度方法</strong></p><pre><code class="language-none">conjugate_gradient(A, b, x_0, n)</code></pre><p>矩阵<span>$A$</span>是对称正定<span>$n\times n$</span>矩阵，<span>$b \neq 0$</span>是一个向量。</p><p><strong>共轭梯度方法公式：</strong></p><ul><li>令<span>$\alpha_k = \frac{r^T_kr_k}{d^T_kAd_k}$</span></li><li>令<span>$\beta_k = \frac{r^T_{k+1}r_{k+1}}{r^T_kr_k}$</span></li></ul><p><span>$\begin{aligned} x_0 &amp;= 初始估计 \\ d_0 &amp;= r_0 = b-Ax_0 \\ x_{k+1} &amp;= x_k + \alpha_k d_k \\ r_{k+1} &amp;= r_k - \alpha_k A d_k \\ d_{k+1} &amp;= r_{k+1} + \beta_k d_k \end{aligned}$</span></p><ul><li>当<span>$r_k=0$</span>时，方程便得以求解</li></ul><p>共轭梯度方法需要在每一步更新三个向量：</p><ul><li><span>$x_k$</span>: 表示第<span>$k$</span>步的近似解。<ul><li>更新公式：<span>$x_{k+1} = x_k + \alpha_k d_k$</span>`</li></ul></li><li><span>$r_k$</span>: 表示近似解<span>$x_k$</span>的余项。<ul><li>更新公式：<span>$r_{k+1} = r_k - \alpha_k A d_k$</span></li></ul></li><li><span>$d_k$</span>: 表示用于更新<span>$x_k$</span>得到改进的<span>$x_{k+1}$</span>时，所使用的新的搜索方向。<ul><li>更新公式：<span>$d_{k+1} = r_{k+1} + \beta_k d_k$</span></li></ul></li></ul><p>共轭梯度方法成功的关键：</p><ul><li>所有的余项<span>$r_k$</span>两两正交: <span>$r^T_kr_j = 0,j&lt;k$</span></li><li>方向<span>$d_k$</span>两两<span>$A$</span>共轭: <span>$d^T_k A d_j = 0,j&lt;k$</span></li></ul><p>同时为了保证下一个余项向量与前面所有余项向量都正交</p><ul><li>余项<span>$r_{k+1}$</span>和方向<span>$d_k$</span>是正交的</li><li><span>$r_j$</span>和方向<span>$d_k$</span>是A共轭的(j&lt;k)</li></ul><p><strong>关于<span>$\alpha_k$</span>的推导:</strong></p><ul><li>需要精确<span>$\alpha_k$</span>使得新的余项<span>$r_{k+1}$</span>和方向<span>$d_k$</span>正交</li></ul><p><span>$\begin{aligned} x_{k+1} &amp;= x_k + \alpha_k d_k \\ b-Ax_{k+1} &amp;= b-Ax_k - \alpha_k A d_k \\ r_{k+1} &amp;= r_k - \alpha_k A d_k \\ 0 = d^T_kr_{k+1} &amp;= d^T_k r_k- \alpha_k d^T_k A d_k \\ \alpha_k &amp;= \frac{d^T_kr_k}{d^T_kAd_k} \end{aligned}$</span></p><ul><li>因为<span>$r_k$</span>和方向<span>$d_{k-1}$</span>是正交</li></ul><p><span>$\begin{aligned} d_k-r_k &amp;= \beta_{k-1}d_{k-1} \\ r^T_kd_k - r^T_kr_k &amp;= 0 \end{aligned}$</span></p><ul><li>可得<span>$\alpha_k = \frac{r^T_kr_k}{d^T_kAd_k}$</span></li></ul><p><strong>关于<span>$\beta_k$</span>的推导:</strong></p><p><span>$\begin{aligned} d_{k+1} &amp;= r_{k+1} + \beta_k d_k \\ 0 = d^T_k A d_{k+1} &amp;= d^T_kAr_{k+1} +\beta_k d^T_kAd_k \\ \beta_k &amp;= -\frac{d^T_kAr_{k+1}}{d^T_kAd_k} \end{aligned}$</span></p><ul><li>因为余项向量两两正交</li></ul><p><span>$\begin{aligned} r_{k+1} &amp;= r_k - \alpha_k A d_k \\ r^T_jr_{k+1} &amp;= r^T_jr_k - \alpha_k r^T_j A d_k = 0 \\ \frac{r^T_jr_k}{r^T_kr_k} &amp;= - \frac{r^T_j A d_k}{d^T_kAd_k} \end{aligned}$</span></p><ul><li>对于<span>$j=k+1$</span></li></ul><p><span>$\beta_k = -\frac{d^T_kAr_{k+1}}{d^T_kAd_k} = \frac{r^T_{k+1}r_{k+1}}{r^T_kr_k}$</span></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2 2; 2 5]
2×2 Array{Int64,2}:
 2  2
 2  5
julia&gt; b = [6;3]
2-element Array{Int64,1}:
 6
 3
julia&gt; x = conjugate_gradient(A, b, [0;0], 2)
2-element Array{Float64,1}:
  4.0
 -0.9999999999999993</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumbericalAnalysisInJulia/blob/7219ea58de8b789c9f80319e3c3195c5e701b832/src/equation_set/conjugate_gradient.jl#L2-L59">source</a></section></article><h2 id="预条件共轭梯度方法-1"><a class="docs-heading-anchor" href="#预条件共轭梯度方法-1">预条件共轭梯度方法</a><a class="docs-heading-anchor-permalink" href="#预条件共轭梯度方法-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationSet.conjugate_gradient_with_pre_condition-NTuple{5,Any}" href="#EquationSet.conjugate_gradient_with_pre_condition-NTuple{5,Any}"><code>EquationSet.conjugate_gradient_with_pre_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>预条件共轭梯度方法</strong></p><pre><code class="language-none">conjugate_gradient_with_pre_condition(A, b, x_0, n)</code></pre><p>共轭梯度法在病态矩阵上性能很差，可以通过<strong>预条件</strong>来得到缓解。主要是将问题转化为良态矩阵系统然后再实施共轭梯度法。</p><p>矩阵<span>$A$</span>是对称正定<span>$n\times n$</span>矩阵，<span>$b \neq 0$</span>是一个向量。</p><p>预条件形式：</p><div>\[M^{-1}Ax = M^{-1}b\]</div><p>其中<span>$M$</span>是可逆的<span>$n \times n$</span>矩阵，称为<strong>预条件因子</strong>。矩阵<span>$M$</span>应满足：</p><ul><li>与矩阵<span>$A$</span>足够接近</li><li>容易求逆</li></ul><p>但是和矩阵<span>$A$</span>最接近的是<span>$A$</span>自身，使用<span>$M=A$</span>会把问题条件数变为1，但是一般<span>$A$</span>不容易求逆。而最容易求逆的矩阵是单位矩阵，但它又不能减低条件数。</p><p>因此最完美的预条件矩阵位于两者的中间，同时具备二者的性质。</p><ul><li>一种特别简单的方式是<strong>雅可比预条件子<span>$M=D$</span></strong>（<span>$D$</span>是<span>$A$</span>的对角线矩阵）</li></ul><p><strong>预条件共轭梯度方法公式：</strong></p><ul><li>令<span>$\alpha_k = \frac{r^T_kz_k}{d^T_kAd_k}$</span></li><li>令<span>$\beta_k = \frac{r^T_{k+1}z_{k+1}}{r^T_kz_k}$</span></li></ul><p><span>$\begin{aligned} x_0 &amp;= 初始估计 \\ d_0 &amp;= r_0 = b-Ax_0 \\ x_{k+1} &amp;= x_k + \alpha_k d_k \\ r_{k+1} &amp;= r_k - \alpha_k A d_k \\ z_{k+1} &amp;= M^{-1}r_{k+1} \\ d_{k+1} &amp;= z_{k+1} + \beta_k d_k \end{aligned}$</span></p><ul><li>当<span>$r_k=0$</span>时，<span>$x_k$</span>就是方程组的解</li></ul><p>预条件共轭梯度方法需要在每一步更新四个向量：</p><ul><li><span>$x_k$</span>: 表示第<span>$k$</span>步的近似解。<ul><li>更新公式：<span>$x_{k+1} = x_k + \alpha_k d_k$</span>`</li></ul></li><li><span>$r_k$</span>: 表示近似解<span>$x_k$</span>的余项。<ul><li>更新公式：<span>$r_{k+1} = r_k - \alpha_k A d_k$</span></li></ul></li><li><span>$z_k$</span>: 表示预条件系统的余项。<span>$z_k = M^{-1}b - M^{-1}Ax_k = m^{-1}r_k$</span><ul><li>更新公式：<span>$z_{k+1} = M^{-1}r_{k+1}$</span></li></ul></li><li><span>$d_k$</span>: 表示用于更新<span>$x_k$</span>得到改进的<span>$x_{k+1}$</span>时，所使用的新的搜索方向。<ul><li>更新公式：<span>$d_{k+1} = z_{k+1} + \beta_k d_k$</span></li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra

julia&gt; A = [1 -1 0; -1 2 1; 0 1 2]
3×3 Array{Int64,2}:
  1  -1  0
 -1   2  1
  0   1  2
julia&gt; b = [0;2;3]
3-element Array{Int64,1}:
 0
 2
 3
julia&gt; M = diagm(diag(A))    # 雅可比预条件子
3×3 Array{Int64,2}:
 1  0  0
 0  2  0
 0  0  2
julia&gt; x = conjugate_gradient_with_pre_condition(A, b, [0;0;0], 3, M)
3-element Array{Float64,1}:
 0.9999999999999996
 0.9999999999999998
 0.9999999999999999

julia&gt; A = [1 -1 0; -1 2 1; 0 1 5]
3×3 Array{Int64,2}:
  1  -1  0
 -1   2  1
  0   1  5
julia&gt; b = [3;-3;4]
3-element Array{Int64,1}:
  3
 -3
  4
julia&gt; M = diagm(diag(A))    # 雅可比预条件子
3×3 Array{Int64,2}:
 1  0  0
 0  2  0
 0  0  5
julia&gt; x = conjugate_gradient_with_pre_condition(A, b, [0;0;0], 3, M)
3-element Array{Float64,1}:
  1.9999999999999996
 -1.0
  0.9999999999999999</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumbericalAnalysisInJulia/blob/7219ea58de8b789c9f80319e3c3195c5e701b832/src/equation_set/conjugate_gradient_with_pre_condition.jl#L1-L84">source</a></section></article><h2 id="使用对称连续过松弛(SSOR)预条件子的共轭梯度法-1"><a class="docs-heading-anchor" href="#使用对称连续过松弛(SSOR)预条件子的共轭梯度法-1">使用对称连续过松弛(SSOR)预条件子的共轭梯度法</a><a class="docs-heading-anchor-permalink" href="#使用对称连续过松弛(SSOR)预条件子的共轭梯度法-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationSet.ssor" href="#EquationSet.ssor"><code>EquationSet.ssor</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>对称连续过松弛(SSOR)预条件共轭梯度法</strong></p><pre><code class="language-none">ssor(A, b, x_0, n, ω=1)</code></pre><p><span>$M = (D + \omega L)D^{-1} (D + \omega U)$</span></p><p>同SOR方法中，<span>$A = L+D+U$</span>，<span>$\omega$</span>是0和2之间的常数。</p><p>当<span>$\omega =1$</span>时，它也被称为<strong>高斯-塞德尔预条件子</strong></p><p><span>$\begin{aligned} M &amp;= (D + \omega L)D^{-1} (D + \omega U) \\ M &amp;= (I + \omega LD^{-1}) (D + \omega U) \\ z &amp;= M^{-1}v \\ Mz &amp;= v \\ &amp; (I + \omega LD^{-1})c = v \\ &amp; (D + \omega U)z = c \end{aligned}$</span></p><p>对于稀疏矩阵，两次回代所花的时间和非零元素的个数成正比</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumbericalAnalysisInJulia/blob/7219ea58de8b789c9f80319e3c3195c5e701b832/src/equation_set/ssor.jl#L1-L14">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../iteration_method/">« 迭代方法</a><a class="docs-footer-nextpage" href="../nonlinear_equation_set/">非线性方程组 »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 5 February 2020 05:53">Wednesday 5 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
