var documenterSearchIndex = {"docs":
[{"location":"numberical_analysis/equation_set/lu_factorization/#LU分解-1","page":"LU分解","title":"LU分解","text":"","category":"section"},{"location":"numberical_analysis/equation_set/lu_factorization/#","page":"LU分解","title":"LU分解","text":"CurrentModule = EquationSet","category":"page"},{"location":"numberical_analysis/equation_set/lu_factorization/#","page":"LU分解","title":"LU分解","text":"Pages   = [\"lu_factorization.md\"]","category":"page"},{"location":"numberical_analysis/equation_set/lu_factorization/#LU分解–高斯消去法的矩阵形式-1","page":"LU分解","title":"LU分解–高斯消去法的矩阵形式","text":"","category":"section"},{"location":"numberical_analysis/equation_set/lu_factorization/#","page":"LU分解","title":"LU分解","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :lu_factorization ","category":"page"},{"location":"numberical_analysis/equation_set/lu_factorization/#EquationSet.lu_factorization-Tuple{Any,Any,Any}","page":"LU分解","title":"EquationSet.lu_factorization","text":"LU分解–高斯消去法的矩阵形式\n\nlu_factorization(A, b, n)\n\n将系数矩阵分解为下三角矩阵L和上三角矩阵U，再求解x，可降低运算次数。\n\nLU分解使得在朴素的高斯消元法中的消去过程，向量b没有参与运算，直到回代过程才参与运算(两次)，相比而言，当n非常大时，计算次数会有明显的差异\n\n注意：当前实现的算法如果遇到0主元会抛出异常并终止\n\nLU分解–高斯消去法的矩阵形式推导：\n\nbeginaligned A = LU  Ax =b Longleftrightarrow LUx=b  Lc = b Rightarrow c  Ux =c Rightarrow x endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nn: 方程数\n\nExample\n\njulia> A = Float64[1 2 -1;2 1 -2;-3 1 1]\n3×3 Array{Float64,2}:\n  1.0  2.0  -1.0\n  2.0  1.0  -2.0\n -3.0  1.0   1.0\njulia> b = Float64[3; 3; -6]\n3-element Array{Float64,1}:\n  3.0\n  3.0\n -6.0\njulia> x = lu_factorization(A,b,3)\n3×1 Array{Float64,2}:\n 3.0\n 1.0\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/lu_factorization/#PALU分解–部分主元法-1","page":"LU分解","title":"PA=LU分解–部分主元法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/lu_factorization/#","page":"LU分解","title":"LU分解","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :lu_factorization_with_permutation","category":"page"},{"location":"numberical_analysis/equation_set/lu_factorization/#EquationSet.lu_factorization_with_permutation-Tuple{Any,Any,Any}","page":"LU分解","title":"EquationSet.lu_factorization_with_permutation","text":"PA=LU分解\n\nlu_factorization_with_permutation(A, b, n)\n\n为避免淹没问题，在对矩阵A进行LU分解前，先对主元列进行判断，将主元列最大的一行与当前的首行进行置换\n\nPA=LU分解推导：\n\nbeginaligned P  置换矩阵  A = LU Longleftrightarrow PA=LU endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nn: 方程数\n\nExample\n\njulia> A = Float64[2 1 5; 4 4 -4; 1 3 1]\n3×3 Array{Float64,2}:\n 2.0  1.0   5.0\n 4.0  4.0  -4.0\n 1.0  3.0   1.0\njulia> b = Float64[5; 0; 6]\n3-element Array{Float64,1}:\n 5.0\n 0.0\n 6.0\njulia> x = lu_factorization_with_permutation(A,b,3)\n3×1 Array{Float64,2}:\n -1.0\n  2.0\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/gauss_elimination/#高斯消去法-1","page":"高斯消去法","title":"高斯消去法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/gauss_elimination/#","page":"高斯消去法","title":"高斯消去法","text":"CurrentModule = EquationSet","category":"page"},{"location":"numberical_analysis/equation_set/gauss_elimination/#","page":"高斯消去法","title":"高斯消去法","text":"Pages   = [\"gauss_elimination.md\"]","category":"page"},{"location":"numberical_analysis/equation_set/gauss_elimination/#朴素的高斯消去法-1","page":"高斯消去法","title":"朴素的高斯消去法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/gauss_elimination/#","page":"高斯消去法","title":"高斯消去法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :naive_gauss_elimination","category":"page"},{"location":"numberical_analysis/equation_set/gauss_elimination/#EquationSet.naive_gauss_elimination-Tuple{Any,Any,Any}","page":"高斯消去法","title":"EquationSet.naive_gauss_elimination","text":"朴素的高斯消去法\n\nnaive_gauss_elimination(A, b, n)\n\n朴素的高斯消去法求解方程组。高斯方法是求解线性方程组的直接方法。\n\n消去步骤\n注意：消去过程采取j+1:n的方式迭代，完成后应将a[i,j]置为0， 但这里并没有这么做，是因为在后面的步骤中，并没有用到它，所以省去了置为0的过程\n回代步骤\n从底部开始，逐渐向上求解对应的方程\n\n注意：当前实现的算法如果遇到0主元会抛出异常并终止\n\nAx=b\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nn: 方程数\n\nExample\n\njulia> A = [1 2 -1;2 1 -2;-3 1 1]\n3×3 Array{Int64,2}:\n  1  2  -1\n  2  1  -2\n -3  1   1\njulia> b = [3; 3; -6]\n3-element Array{Int64,1}:\n  3\n  3\n -6\njulia> x = naive_gauss_elimination(A,b,3)\n3×1 Array{Float64,2}:\n 3.0\n 1.0\n 2.0\njulia> A    # 其实表示的应是[1 2 -1; 0 -3 0; 0 0 -2]\n3×3 Array{Int64,2}:\n  1   2  -1\n  2  -3   0\n -3   7  -2\njulia> b\n3-element Array{Int64,1}:\n  3\n -3\n -4\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/#求解n元方程-1","page":"目录","title":"求解n元方程","text":"","category":"section"},{"location":"numberical_analysis/equation_set/#","page":"目录","title":"目录","text":"CurrentModule = EquationSet","category":"page"},{"location":"numberical_analysis/equation_set/#Content-1","page":"目录","title":"Content","text":"","category":"section"},{"location":"numberical_analysis/equation_set/#","page":"目录","title":"目录","text":"Pages = map(file -> joinpath(\"equation_set\", file), readdir(\"equation_set\"))\nDepth = 3","category":"page"},{"location":"numberical_analysis/equation_set/#Index-1","page":"目录","title":"Index","text":"","category":"section"},{"location":"numberical_analysis/equation_set/#","page":"目录","title":"目录","text":"Pages   = map(file -> joinpath(\"equation_set\", file), readdir(\"equation_set\"))","category":"page"},{"location":"numberical_analysis/equation_solving/bisect/#二分法-1","page":"二分法","title":"二分法","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/bisect/#","page":"二分法","title":"二分法","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numberical_analysis/equation_solving/bisect/#","page":"二分法","title":"二分法","text":"Pages   = [\"bisect.md\"]","category":"page"},{"location":"numberical_analysis/equation_solving/bisect/#二分法-2","page":"二分法","title":"二分法","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/bisect/#","page":"二分法","title":"二分法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :bisect","category":"page"},{"location":"numberical_analysis/equation_solving/bisect/#EquationSolving.bisect-NTuple{4,Any}","page":"二分法","title":"EquationSolving.bisect","text":"二分法\n\nbisect(fn, a, b, err)\n\n二分法求解方程解\n\nArguments\n\nfn: 函数\na: 左区间点\nb: 右区间点\nerr: 误差\n\nExample\n\njulia> bisect(x->x^3+x-1, 0, 1, 0.00005)\n0.682342529296875\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_solving/fixed_point_iteration/#不动点迭代法-1","page":"不动点迭代法","title":"不动点迭代法","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/fixed_point_iteration/#","page":"不动点迭代法","title":"不动点迭代法","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numberical_analysis/equation_solving/fixed_point_iteration/#","page":"不动点迭代法","title":"不动点迭代法","text":"Pages   = [\"fixed_point_iteration.md\"]","category":"page"},{"location":"numberical_analysis/equation_solving/fixed_point_iteration/#不动点迭代法-2","page":"不动点迭代法","title":"不动点迭代法","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/fixed_point_iteration/#","page":"不动点迭代法","title":"不动点迭代法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :fixed_point_iteration","category":"page"},{"location":"numberical_analysis/equation_solving/fixed_point_iteration/#EquationSolving.fixed_point_iteration-Tuple{Any,Any,Any}","page":"不动点迭代法","title":"EquationSolving.fixed_point_iteration","text":"不动点迭代法\n\nfixed_point_iteration(g, x_0, k)\n\n不动点迭代法求解函数值\n\n不动点迭代法迭代公式：\n\nbeginaligned f(x)=g(x)-x  x_0 = 初始估计 x_i+1 = g(x_i)(i=0123) endaligned\n\nArguments\n\ng: g(x)函数\nx_0: 初始估计值\nk: 迭代次数\n\nExample\n\njulia> fixed_point_iteration(x-> cos(x), 0, 100)\n0.7390851332151607\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/interpolation_polynomial/#插值多项式-1","page":"目录","title":"插值多项式","text":"","category":"section"},{"location":"numberical_analysis/interpolation_polynomial/#","page":"目录","title":"目录","text":"CurrentModule = InterpolationPolynomial","category":"page"},{"location":"numberical_analysis/interpolation_polynomial/#Content-1","page":"目录","title":"Content","text":"","category":"section"},{"location":"numberical_analysis/interpolation_polynomial/#","page":"目录","title":"目录","text":"Pages = map(file -> joinpath(\"interpolation_polynomial\", file), readdir(\"interpolation_polynomial\"))\nDepth = 3","category":"page"},{"location":"numberical_analysis/interpolation_polynomial/#Index-1","page":"目录","title":"Index","text":"","category":"section"},{"location":"numberical_analysis/interpolation_polynomial/#","page":"目录","title":"目录","text":"Pages   = map(file -> joinpath(\"interpolation_polynomial\", file), readdir(\"interpolation_polynomial\"))","category":"page"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#非线性方程组-1","page":"非线性方程组","title":"非线性方程组","text":"","category":"section"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"CurrentModule = EquationSet","category":"page"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"Pages   = [\"nonlinear_equation_set.md\"]","category":"page"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#多变量牛顿法-1","page":"非线性方程组","title":"多变量牛顿法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :mult_newton_method","category":"page"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#EquationSet.mult_newton_method-NTuple{4,Any}","page":"非线性方程组","title":"EquationSet.mult_newton_method","text":"多变量牛顿方法\n\nmult_newton_method(f, df, x_0, k)\n\n多变量牛顿方法是由单变量牛顿方法推演而来。将单变量情况下的导函数f，定义为向量值函数F的雅可比矩阵。\n\nvec x=(uvw)\n\nF(x) = 0\n\n即 F(x) = left  beginmatrix f_1(x)  f_2(x)  f_3(x)   endmatrix right  = left  beginmatrix f_1(u v w)  f_2(u v w)  f_3(u v w)   endmatrix right  = 0\n\n雅可比矩阵DF(x)\n\nDF(x) = left  beginmatrix fracpartial f_1partial u space fracpartial f_1partial v space fracpartial f_1partial w space   fracpartial f_2partial u space fracpartial f_2partial v space fracpartial f_2partial w space   fracpartial f_3partial u space fracpartial f_3partial v space fracpartial f_3partial w space    endmatrix right \n\n令x=r是根，x_0是当前近似估计，根据泰勒一级展开，忽略二次余项\n\nbeginaligned 0 = F(r) approx F(x_0) + DF(x_0)cdot (r-x_0)  -DF(x_0)^-1F(x_0) approx r-x_0 endaligned\n\n多变量牛顿方法迭代公式：\n\nbeginaligned x_0 = 初始估计  x_k+1 = x_k- (DF(x_k))^-1F(x_k) space  space k=012 endaligned\n\n由于计算矩阵逆的代价通常较大，令s是DF(x_k)s = F(x_k)的解，然后在每步中使用高斯消去代替计算矩阵的逆，减少运算次数\n\nbeginaligned DF(x_k)s = F(x_k)  x_k+1 = x_k - s endaligned\n\nExample\n\n# F = [(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)]\n# DF = [(u,v)->(-3*u^2) (u,v)->(1); (u,v)->(2u) (u,v)->(2v)]\n# x_0 = [1, 2]\njulia> mult_newton_method([(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)],  [(u,v)->(-3*u^2) (u,v)->(1); (u,v)->(2u) (u,v)->(2v)], [1, 2], 10)\n2×1 Array{Float64,2}:\n 0.826031357654187\n 0.5636241621612585\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#Broyden-方法-1","page":"非线性方程组","title":"Broyden 方法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :broyden","category":"page"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#EquationSet.broyden-NTuple{4,Any}","page":"非线性方程组","title":"EquationSet.broyden","text":"Broyden方法\n\nbroyden(F, A_0, x_0, k)\n\n当无法得到雅可比矩阵DF时，Broyden方法通常被认为是一种次优的方法。\n\n将设A_i是第i步可以得到的雅可比矩阵的最优近似，并被用于：\n\nx_k+1 = x_k - A^-1_iF(x_i)\n\n为了根据A_i更新得到A_i+1。首先注意到雅可比矩阵满足：\n\nbeginaligned A_i+1delta_i+1 = Delta_i+1  delta_i+1 = x_i+1 - x_i  Delta_i+1 = F(x_i+1) - F(x_i) endaligned\n\n要求所有满足delta^T_i+1omega = 0的omega：\n\nA_i+1omega = A_i omega\n\n则同时满足上述条件的矩阵如下:\n\nA_i+1 = A_i + frac(Delta_i+1 - A_idelta_i)delta^T_i+1delta^T_i+1delta_i+1\n\nExample\n\n# F = [(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)]\n# A_0 = Matrix{Float64}(I, 2, 2)\n# x_0 = Float64[1, 2]\njulia> using LinearAlgebra\n\njulia> broyden([(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)],  Matrix{Float64}(I, 2, 2), Float64[1, 2], 20)\n2×1 Array{Float64,2}:\n 0.8260271593976959\n 0.5635461739578368\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#Broyden-方法-2","page":"非线性方程组","title":"BroydenⅡ 方法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :broyden2","category":"page"},{"location":"numberical_analysis/equation_set/nonlinear_equation_set/#EquationSet.broyden2-NTuple{4,Any}","page":"非线性方程组","title":"EquationSet.broyden2","text":"BroydenⅡ 方法\n\nbroyden2(F, B_0, x_0, k)\n\nBroyden的第二种方式避免相对代价较大的矩阵求解步骤。相比近似DF导数，同样我们可以近似DF的逆\n\n基于B_i = A^-1_i，我们希望得到：\n\ndelta_i+1 = B_i+1Delta_i+1\n\n同样为了根据B_i更新得到B_i+1。首先注意到雅可比矩阵满足：\n\nbeginaligned A_i+1delta_i+1 = Delta_i+1  delta_i+1 = x_i+1 - x_i  Delta_i+1 = F(x_i+1) - F(x_i) endaligned\n\n要求所有满足delta^T_i+1omega = 0的omega：\n\nA_i+1omega = A_i omega\n\n或者：\n\nB_i+1A_iomega = omega\n\n则同时满足上述条件的矩阵如下:\n\nB_i+1 = B_i + frac(delta_i+1 - B_iDelta_i)delta^T_i+1B_idelta^T_i+1B_iDelta_i+1\n\n不再需要进行矩阵求解的迭代公式：\n\nx_i+1 = x_i - B_iF(x_i)\n\nExample\n\n# F = [(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)]\n# B_0 = Matrix{Float64}(I, 2, 2)\n# x_0 = Float64[1, 2]\njulia> using LinearAlgebra\n\njulia> broyden2([(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)],  Matrix{Float64}(I, 2, 2), Float64[1, 2], 50)\n2-element Array{Float64,1}:\n 0.8260313576541872\n 0.5636241621612585\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_solving/secant/#割线方法-1","page":"割线方法","title":"割线方法","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/secant/#","page":"割线方法","title":"割线方法","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numberical_analysis/equation_solving/secant/#","page":"割线方法","title":"割线方法","text":"Pages   = [\"secant.md\"]","category":"page"},{"location":"numberical_analysis/equation_solving/secant/#割线方法-2","page":"割线方法","title":"割线方法","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/secant/#","page":"割线方法","title":"割线方法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :secant","category":"page"},{"location":"numberical_analysis/equation_solving/secant/#EquationSolving.secant-NTuple{4,Any}","page":"割线方法","title":"EquationSolving.secant","text":"割线方法\n\nsecant(f, x_0, x-1, k)\n\n割线方法法计算方程解。\n\n当难以计算函数导数时，割线方法是牛顿迭代法的一个很好的替代。\n割线方法需要提供两个初始估计\n\n割线方法迭代公式\n\nbeginaligned x_0 x_1 = 初始估计值 x_i+1 = x_i - frac f(x_i)(x_i-x_i-1)f(x_i)-f(x_i-1)(i=0123) endaligned\n\nArguments\n\nf: f(x)函数\nx_0: 初始估计值1\nx_1: 初始估计值2\nk: 迭代次数\n\nExample\n\njulia> secant(x->x^3 +x -1, 0, 1, 20)\n0.6823278038280193\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_solving/secant/#试位方法-1","page":"割线方法","title":"试位方法","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/secant/#","page":"割线方法","title":"割线方法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :regula_falsi","category":"page"},{"location":"numberical_analysis/equation_solving/secant/#EquationSolving.regula_falsi-NTuple{4,Any}","page":"割线方法","title":"EquationSolving.regula_falsi","text":"试位方法\n\nregula_falsi(f, a, b, k)\n\n试位方法是割线方法推广，类似二分法，但其中的中点被类似割线方法的近似所替换\n\n试位方法迭代公式\n\nbeginaligned a b = 初始估计值 c = a - frac f(a)(a-b)f(a)-f(b) = frac bf(a)-af(b)f(a)-f(b) endaligned\n\nArguments\n\nf: f(x)函数\na: 初始估计值1\nb: 初始估计值2\nk: 迭代次数\n\nExample\n\njulia> regula_falsi(x->x^3 +x -1, 0, 1, 100)\n0.6823278038280193\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_solving/newton_method/#牛顿方法-1","page":"牛顿方法","title":"牛顿方法","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/newton_method/#","page":"牛顿方法","title":"牛顿方法","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numberical_analysis/equation_solving/newton_method/#","page":"牛顿方法","title":"牛顿方法","text":"Pages   = [\"newton_method.md\"]","category":"page"},{"location":"numberical_analysis/equation_solving/newton_method/#牛顿拉普森方法-1","page":"牛顿方法","title":"牛顿拉普森方法","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/newton_method/#","page":"牛顿方法","title":"牛顿方法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :newton_raphson_method","category":"page"},{"location":"numberical_analysis/equation_solving/newton_method/#EquationSolving.newton_raphson_method","page":"牛顿方法","title":"EquationSolving.newton_raphson_method","text":"牛顿拉普森方法\n\nnewton_raphson_method(f, df, x_0, k, m=1)\n\n牛顿拉普森迭代法计算方程解\n\n牛顿拉普森方法迭代公式\n\nbeginaligned x_0 = 初始估计  x_i+1 = x_i - frac f(x_i)f(x_i)(i=0123) endaligned\n\nArguments\n\nf: f(x)函数\ndf: f(x)的导函数\nx_0: 初始估计值\nk: 迭代次数\nm: 重根树(default=1)\n\nExample\n\njulia> newton_raphson_method(x->x^3 +x -1, x->3x^2 +1, -0.7, 20)\n0.6823278038280193\n\n\n\n\n\n","category":"function"},{"location":"numberical_analysis/polyomial/#多项式求值-1","page":"多项式求值","title":"多项式求值","text":"","category":"section"},{"location":"numberical_analysis/polyomial/#","page":"多项式求值","title":"多项式求值","text":"CurrentModule = Polyomial","category":"page"},{"location":"numberical_analysis/polyomial/#Content-1","page":"多项式求值","title":"Content","text":"","category":"section"},{"location":"numberical_analysis/polyomial/#","page":"多项式求值","title":"多项式求值","text":"Pages = map(file -> joinpath(\"equation_solving\", file), readdir(\"equation_solving\"))\nDepth = 3","category":"page"},{"location":"numberical_analysis/polyomial/#Index-1","page":"多项式求值","title":"Index","text":"","category":"section"},{"location":"numberical_analysis/polyomial/#","page":"多项式求值","title":"多项式求值","text":"Pages   = [\"polyomial.md\"]","category":"page"},{"location":"numberical_analysis/polyomial/#霍纳方法-1","page":"多项式求值","title":"霍纳方法","text":"","category":"section"},{"location":"numberical_analysis/polyomial/#","page":"多项式求值","title":"多项式求值","text":"Modules = [Polyomial]\nFilter = f -> nameof(f) == :horner_rule","category":"page"},{"location":"numberical_analysis/polyomial/#Polyomial.horner_rule-NTuple{4,Any}","page":"多项式求值","title":"Polyomial.horner_rule","text":"霍纳法则\n\nhorner_rule(rank, constants, x, base_points)\n\n对多项式求值的霍纳法则(嵌套乘法)\n\nc_1 + (x-r_1)(c_2+(x-r_2)(c_3 + (x-r_3)(c_4+ (x-r_4)c_5)))\n\nArguments\n\nrank: 多项式的阶\nconstants: rank+1个系数数组，第一个是常数项\nx::Real: 进行求值带入的x\nbase_points: 每一阶的x的基点数组\n\nUsage\n\njulia> horner_rule(4, [-1 5 -3 3 2], 1/2, [0 0 0 0])\n1.25\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/iteration_method/#迭代方法-1","page":"迭代方法","title":"迭代方法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"CurrentModule = EquationSet","category":"page"},{"location":"numberical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"Pages   = [\"iteration_method.md\"]","category":"page"},{"location":"numberical_analysis/equation_set/iteration_method/#雅可比方法-1","page":"迭代方法","title":"雅可比方法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :jacobi","category":"page"},{"location":"numberical_analysis/equation_set/iteration_method/#EquationSet.jacobi-NTuple{5,Any}","page":"迭代方法","title":"EquationSet.jacobi","text":"雅可比方法\n\njacobi(A, b, x_0, n, k)\n\n雅可比方法是方程组系统中的一种形式的不动点迭代。在FPI中第一步是重写方程，进而求解未知量。\n\n雅可比方法中，是如下步骤：\n\n求解第i个方程得到第i个未知变量\n然后使用不动点迭代，从初始估计开始，进行迭代\n\n如果矩阵A是严格对角占优矩阵(主对角线的值在其所在行是最大的)，那么A是非奇异矩阵，且对于所有的向量b和初始估计，对Ax=b应用雅可比方法都会收敛到(唯一)解\n\n下式中：\n\nD表示A的主对角线矩阵\nL表示A的下三角矩阵(主对角线以下的元素)\nU表示A的上三角矩阵(主对角线以上的元素)\n\nbeginaligned Ax = b Longleftrightarrow (L+D+U)x = b  Dx = b-(L+U)x  x = D^-1(b-(L+U)x) endaligned\n\n雅可比方法迭代公式：\n\nbeginaligned x_0 = 初始估计  x_k+1 = D^-1(b-(L+U)x_k) k=012 endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nx_0: 初始估计(向量)\nn: 方程数\nk: 迭代次数\n\nExample\n\njulia> A = Float64[3 1; 1 2]\n2×2 Array{Float64,2}:\n 3.0  1.0\n 1.0  2.0\njulia> b = Float64[5; 5]\n2-element Array{Float64,1}:\n 5.0\n 5.0\njulia> x = jacobi(A,b,[0;0], 2, 100)\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/iteration_method/#高斯-赛德尔方法-1","page":"迭代方法","title":"高斯-赛德尔方法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :gauss_seidel","category":"page"},{"location":"numberical_analysis/equation_set/iteration_method/#EquationSet.gauss_seidel-NTuple{5,Any}","page":"迭代方法","title":"EquationSet.gauss_seidel","text":"高斯-赛德尔方法\n\ngauss_seidel(A, b, x_0, n, k)\n\n高斯-赛德尔方法和雅可比方法非常相似，唯一的差异的在于，高斯-赛德尔方法在每一步中都会用到最近更新的未知变量的值。\n\n同样如果矩阵A是严格对角占优矩阵(主对角线的值在其所在行是最大的)，那么A是非奇异矩阵，且对于所有的向量b和初始估计，对Ax=b应用高斯-赛德尔方法都会收敛到(唯一)解\n\n下式中：\n\nD表示A的主对角线矩阵\nL表示A的下三角矩阵(主对角线以下的元素)\nU表示A的上三角矩阵(主对角线以上的元素)\n\nAx = b Longleftrightarrow (L+D)x_k+1 = b - Ux_k \n\n高斯-赛德尔方法迭代公式：\n\nbeginaligned x_0 = 初始估计  x_k+1 = D^-1(b-Lx_k+1-Ux_k) k=012 endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nx_0: 初始估计(向量)\nn: 方程数\nk: 迭代次数\n\nExample\n\njulia> A = Float64[3 1 -1; 2 4 1; -1 2 5]\n3×3 Array{Float64,2}:\n  3.0  1.0  -1.0\n  2.0  4.0   1.0\n -1.0  2.0   5.0\njulia> b = Float64[4; 1; 1]\n3-element Array{Float64,1}:\n 4.0\n 1.0\n 1.0\njulia> x_0 = Float64[0;0;0]\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\njulia> x = gauss_seidel(A, b, x_0, 3, 50)    # 该例中约50步收敛\n3-element Array{Float64,1}:\n  2.0\n -1.0\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/iteration_method/#连续过松弛方法-1","page":"迭代方法","title":"连续过松弛方法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :sor","category":"page"},{"location":"numberical_analysis/equation_set/iteration_method/#EquationSet.sor","page":"迭代方法","title":"EquationSet.sor","text":"连续过松弛(SOR)\n\nsor(A, b, x_0, n, k, ω=1.25)\n\n连续过松弛方法使用高斯-赛德尔方法的求解方向，并使用过松弛以加快收敛速度。\n\n令omega是一个实数，将新的估计中的每个元素x_k+1定义为omega乘上高斯-赛德尔公式和`1-\\omega乘上当前估计的平均。\n\nomega被称为松弛参数，当omega1时被称为过松弛。\n\n当omega=1时，SOR方法就是高斯-赛德尔方法\n\n连续过松弛(SOR)迭代公式：\n\nbeginaligned x_0 = 初始估计  x_k+1 = (1-omega)x_k + omega D^-1(b-Lx_k+1-Ux_k) k=012 endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nx_0: 初始估计(向量)\nn: 方程数\nk: 迭代次数\nω: 松弛参数(default=1.25)\n\nExample\n\njulia> A = Float64[3 1 -1; 2 4 1; -1 2 5]\n3×3 Array{Float64,2}:\n  3.0  1.0  -1.0\n  2.0  4.0   1.0\n -1.0  2.0   5.0\njulia> b = Float64[4; 1; 1]\n3-element Array{Float64,1}:\n 4.0\n 1.0\n 1.0\njulia> x_0 = Float64[0;0;0]\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\njulia> x = sor(A, b, x_0, 3, 50, 1.25)    # 该例中约30步收敛\n3-element Array{Float64,1}:\n  2.0\n -1.0\n  1.0\n\n\n\n\n\n","category":"function"},{"location":"numberical_analysis/interpolation_polynomial/newton_difference_quotient/#牛顿差商-1","page":"牛顿差商","title":"牛顿差商","text":"","category":"section"},{"location":"numberical_analysis/interpolation_polynomial/newton_difference_quotient/#","page":"牛顿差商","title":"牛顿差商","text":"CurrentModule = InterpolationPolynomial","category":"page"},{"location":"numberical_analysis/interpolation_polynomial/newton_difference_quotient/#","page":"牛顿差商","title":"牛顿差商","text":"Pages   = [\"newton_difference_quotient.md\"]","category":"page"},{"location":"numberical_analysis/interpolation_polynomial/newton_difference_quotient/#牛顿差商-2","page":"牛顿差商","title":"牛顿差商","text":"","category":"section"},{"location":"numberical_analysis/interpolation_polynomial/newton_difference_quotient/#","page":"牛顿差商","title":"牛顿差商","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :newton_difference_quotient","category":"page"},{"location":"numberical_analysis/interpolation_polynomial/newton_difference_quotient/#InterpolationPolynomial.newton_difference_quotient-Tuple{Any,Any}","page":"牛顿差商","title":"InterpolationPolynomial.newton_difference_quotient","text":"牛顿差商\n\nnewton_difference_quotient\n\n牛顿差商给出插值多项式的一种简单形式。给定n个数据点，所得到的结果多项式之多n-1阶\n\n牛顿差商公式定义：\n\n用fx_1  x_n表示(唯一)多项式的下x^n-1项的系数，该多项式的插值(x_1 f(x_1))(x_n f(x_n))\n\nbeginaligned P(x) =  fx_1 + fx_1 x_2(x-x_1) + fx_1 x_2 x_3(x-x_1)(x-x_2)  + fx_1 x_2 x_3 x_4(x-x_1)(x-x_2)(x-x_3)  +  + fx_1  x_n(x-x_1)(x-x_n-1) endaligned\n\n根据唯一性，x_1 x_2  x_n的任意置换结果相同：\n\nfx_1 x_2  x_n = fx_2 x_3  x_n x_1 = fx_2 x_3 x_n-1 x_1 x_n\n\n由此可推导出:\n\nfx_1  x_k = frac fx_2  x_k - fx_1  x_k-1x_k - x_1\n\n以及：\n\nbeginaligned fx_k = f(x_k)  fx_k x_k+1 = frac fx_k+1-fx_kx_k+1- x_k  fx_k x_k+1  f_k+j = frac fx_k+1  x_k+j-fx_k  x_k+j-1x_k+j- x_k endaligned\n\nExample\n\njulia> x = [0 2 3]\n1×3 Array{Int64,2}:\n 0  2  3\njulia> y = [1 2 4]\n1×3 Array{Int64,2}:\n 1  2  4\njulia> newton_difference_quotient(x,y)\n3-element Array{Float64,1}:\n 1.0\n 0.5\n 0.5\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#用于对称正定矩阵的方法-1","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"CurrentModule = EquationSet","category":"page"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Pages   = [\"methods_about_SPD_matrix.md\"]","category":"page"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#楚列斯基分解法-1","page":"用于对称正定矩阵的方法","title":"楚列斯基分解法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :cholesky_decomposition ","category":"page"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#EquationSet.cholesky_decomposition-Tuple{Any,Any}","page":"用于对称正定矩阵的方法","title":"EquationSet.cholesky_decomposition","text":"楚列斯基分解\n\ncholesky_decomposition(A, n)\n\n楚列斯基分解定理：A是n times n对称正定矩阵，则存在上三角矩阵R满足A=R^TR\n\nA = left  beginmatrix a  b  b  c endmatrix right  = left  beginmatrix sqrta  0  fracbsqrta  sqrtc-b^2a endmatrix right  left  beginmatrix sqrta  fracbsqrta  0  sqrtc-b^2a endmatrix right =R^TR\n\n对于对称正定矩阵A，求解Ax=b，和LU分解方式相同：\n\nR^Tc=b Longrightarrow c  Rx=c Longrightarrow x\n\n这样针对对称正定矩阵的方程组求解，等于降低了一般的计算代价来实现。\n\nExample\n\njulia> A = Float64[4 -2 2;-2 2 -4; 2 -4 11]\n3×3 Array{Float64,2}:\n  4.0  -2.0   2.0\n -2.0   2.0  -4.0\n  2.0  -4.0  11.0\njulia> R = cholesky_decomposition(A, 3)\n3×3 Array{Float64,2}:\n 2.0  -1.0   1.0\n 0.0   1.0  -3.0\n 0.0   0.0   1.0\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#共轭梯度方法-1","page":"用于对称正定矩阵的方法","title":"共轭梯度方法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :conjugate_gradient ","category":"page"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#EquationSet.conjugate_gradient-NTuple{4,Any}","page":"用于对称正定矩阵的方法","title":"EquationSet.conjugate_gradient","text":"共轭梯度方法\n\nconjugate_gradient(A, b, x_0, n)\n\n矩阵A是对称正定ntimes n矩阵，b neq 0是一个向量。\n\n共轭梯度方法公式：\n\n令alpha_k = fracr^T_kr_kd^T_kAd_k\n令beta_k = fracr^T_k+1r_k+1r^T_kr_k\n\nbeginaligned x_0 = 初始估计  d_0 = r_0 = b-Ax_0  x_k+1 = x_k + alpha_k d_k  r_k+1 = r_k - alpha_k A d_k  d_k+1 = r_k+1 + beta_k d_k endaligned\n\n当r_k=0时，方程便得以求解\n\n共轭梯度方法需要在每一步更新三个向量：\n\nx_k: 表示第k步的近似解。\n更新公式：x_k+1 = x_k + alpha_k d_k`\nr_k: 表示近似解x_k的余项。\n更新公式：r_k+1 = r_k - alpha_k A d_k\nd_k: 表示用于更新x_k得到改进的x_k+1时，所使用的新的搜索方向。\n更新公式：d_k+1 = r_k+1 + beta_k d_k\n\n共轭梯度方法成功的关键：\n\n所有的余项r_k两两正交: r^T_kr_j = 0jk\n方向d_k两两A共轭: d^T_k A d_j = 0jk\n\n同时为了保证下一个余项向量与前面所有余项向量都正交\n\n余项r_k+1和方向d_k是正交的\nr_j和方向d_k是A共轭的(j<k)\n\n关于alpha_k的推导:\n\n需要精确alpha_k使得新的余项r_k+1和方向d_k正交\n\nbeginaligned x_k+1 = x_k + alpha_k d_k  b-Ax_k+1 = b-Ax_k - alpha_k A d_k  r_k+1 = r_k - alpha_k A d_k  0 = d^T_kr_k+1 = d^T_k r_k- alpha_k d^T_k A d_k  alpha_k = fracd^T_kr_kd^T_kAd_k endaligned\n\n因为r_k和方向d_k-1是正交\n\nbeginaligned d_k-r_k = beta_k-1d_k-1  r^T_kd_k - r^T_kr_k = 0 endaligned\n\n可得alpha_k = fracr^T_kr_kd^T_kAd_k\n\n关于beta_k的推导:\n\nbeginaligned d_k+1 = r_k+1 + beta_k d_k  0 = d^T_k A d_k+1 = d^T_kAr_k+1 +beta_k d^T_kAd_k  beta_k = -fracd^T_kAr_k+1d^T_kAd_k endaligned\n\n因为余项向量两两正交\n\nbeginaligned r_k+1 = r_k - alpha_k A d_k  r^T_jr_k+1 = r^T_jr_k - alpha_k r^T_j A d_k = 0  fracr^T_jr_kr^T_kr_k = - fracr^T_j A d_kd^T_kAd_k endaligned\n\n对于j=k+1\n\nbeta_k = -fracd^T_kAr_k+1d^T_kAd_k = fracr^T_k+1r_k+1r^T_kr_k\n\nExample\n\njulia> A = [2 2; 2 5]\n2×2 Array{Int64,2}:\n 2  2\n 2  5\njulia> b = [6;3]\n2-element Array{Int64,1}:\n 6\n 3\njulia> x = conjugate_gradient(A, b, [0;0], 2)\n2-element Array{Float64,1}:\n  4.0\n -0.9999999999999993\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#预条件共轭梯度方法-1","page":"用于对称正定矩阵的方法","title":"预条件共轭梯度方法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :conjugate_gradient_with_pre_condition ","category":"page"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#EquationSet.conjugate_gradient_with_pre_condition-NTuple{5,Any}","page":"用于对称正定矩阵的方法","title":"EquationSet.conjugate_gradient_with_pre_condition","text":"预条件共轭梯度方法\n\nconjugate_gradient_with_pre_condition(A, b, x_0, n)\n\n共轭梯度法在病态矩阵上性能很差，可以通过预条件来得到缓解。主要是将问题转化为良态矩阵系统然后再实施共轭梯度法。\n\n矩阵A是对称正定ntimes n矩阵，b neq 0是一个向量。\n\n预条件形式：\n\nM^-1Ax = M^-1b\n\n其中M是可逆的n times n矩阵，称为预条件因子。矩阵M应满足：\n\n与矩阵A足够接近\n容易求逆\n\n但是和矩阵A最接近的是A自身，使用M=A会把问题条件数变为1，但是一般A不容易求逆。而最容易求逆的矩阵是单位矩阵，但它又不能减低条件数。\n\n因此最完美的预条件矩阵位于两者的中间，同时具备二者的性质。\n\n一种特别简单的方式是雅可比预条件子M=D（D是A的对角线矩阵）\n\n预条件共轭梯度方法公式：\n\n令alpha_k = fracr^T_kz_kd^T_kAd_k\n令beta_k = fracr^T_k+1z_k+1r^T_kz_k\n\nbeginaligned x_0 = 初始估计  d_0 = r_0 = b-Ax_0  x_k+1 = x_k + alpha_k d_k  r_k+1 = r_k - alpha_k A d_k  z_k+1 = M^-1r_k+1  d_k+1 = z_k+1 + beta_k d_k endaligned\n\n当r_k=0时，x_k就是方程组的解\n\n预条件共轭梯度方法需要在每一步更新四个向量：\n\nx_k: 表示第k步的近似解。\n更新公式：x_k+1 = x_k + alpha_k d_k`\nr_k: 表示近似解x_k的余项。\n更新公式：r_k+1 = r_k - alpha_k A d_k\nz_k: 表示预条件系统的余项。z_k = M^-1b - M^-1Ax_k = m^-1r_k\n更新公式：z_k+1 = M^-1r_k+1\nd_k: 表示用于更新x_k得到改进的x_k+1时，所使用的新的搜索方向。\n更新公式：d_k+1 = z_k+1 + beta_k d_k\n\nExample\n\njulia> using LinearAlgebra\n\njulia> A = [1 -1 0; -1 2 1; 0 1 2]\n3×3 Array{Int64,2}:\n  1  -1  0\n -1   2  1\n  0   1  2\njulia> b = [0;2;3]\n3-element Array{Int64,1}:\n 0\n 2\n 3\njulia> M = diagm(diag(A))    # 雅可比预条件子\n3×3 Array{Int64,2}:\n 1  0  0\n 0  2  0\n 0  0  2\njulia> x = conjugate_gradient_with_pre_condition(A, b, [0;0;0], 3, M)\n3-element Array{Float64,1}:\n 0.9999999999999996\n 0.9999999999999998\n 0.9999999999999999\n\njulia> A = [1 -1 0; -1 2 1; 0 1 5]\n3×3 Array{Int64,2}:\n  1  -1  0\n -1   2  1\n  0   1  5\njulia> b = [3;-3;4]\n3-element Array{Int64,1}:\n  3\n -3\n  4\njulia> M = diagm(diag(A))    # 雅可比预条件子\n3×3 Array{Int64,2}:\n 1  0  0\n 0  2  0\n 0  0  5\njulia> x = conjugate_gradient_with_pre_condition(A, b, [0;0;0], 3, M)\n3-element Array{Float64,1}:\n  1.9999999999999996\n -1.0\n  0.9999999999999999\n\n\n\n\n\n","category":"method"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#使用对称连续过松弛(SSOR)预条件子的共轭梯度法-1","page":"用于对称正定矩阵的方法","title":"使用对称连续过松弛(SSOR)预条件子的共轭梯度法","text":"","category":"section"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :ssor ","category":"page"},{"location":"numberical_analysis/equation_set/methods_about_SPD_matrix/#EquationSet.ssor","page":"用于对称正定矩阵的方法","title":"EquationSet.ssor","text":"对称连续过松弛(SSOR)预条件共轭梯度法\n\nssor(A, b, x_0, n, ω=1)\n\nM = (D + omega L)D^-1 (D + omega U)\n\n同SOR方法中，A = L+D+U，omega是0和2之间的常数。\n\n当omega =1时，它也被称为高斯-塞德尔预条件子\n\nbeginaligned M = (D + omega L)D^-1 (D + omega U)  M = (I + omega LD^-1) (D + omega U)  z = M^-1v  Mz = v   (I + omega LD^-1)c = v   (D + omega U)z = c endaligned\n\n对于稀疏矩阵，两次回代所花的时间和非零元素的个数成正比\n\n\n\n\n\n","category":"function"},{"location":"#数值分析(Julia语言描述)-1","page":"Home","title":"数值分析(Julia语言描述)","text":"","category":"section"},{"location":"#Content-1","page":"Home","title":"Content","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"numberical_analysis\", file), readdir(\"numberical_analysis\"))\nDepth = 3","category":"page"},{"location":"#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"numberical_analysis/equation_solving/#求解一元方程-1","page":"目录","title":"求解一元方程","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/#","page":"目录","title":"目录","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numberical_analysis/equation_solving/#Content-1","page":"目录","title":"Content","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/#","page":"目录","title":"目录","text":"Pages = map(file -> joinpath(\"equation_solving\", file), readdir(\"equation_solving\"))\nDepth = 3","category":"page"},{"location":"numberical_analysis/equation_solving/#Index-1","page":"目录","title":"Index","text":"","category":"section"},{"location":"numberical_analysis/equation_solving/#","page":"目录","title":"目录","text":"Pages   = map(file -> joinpath(\"equation_solving\", file), readdir(\"equation_solving\"))","category":"page"}]
}
