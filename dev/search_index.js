var documenterSearchIndex = {"docs":
[{"location":"numerical_analysis/least_square/#最小二乘-1","page":"目录","title":"最小二乘","text":"","category":"section"},{"location":"numerical_analysis/least_square/#","page":"目录","title":"目录","text":"CurrentModule = LeastSquare","category":"page"},{"location":"numerical_analysis/least_square/#Content-1","page":"目录","title":"Content","text":"","category":"section"},{"location":"numerical_analysis/least_square/#","page":"目录","title":"目录","text":"Pages = [\n    \"least_square/normal_equation.md\",\n    \"least_square/gram_schmidt_orthogon.md\",\n    \"least_square/least_square_and_qr.md\",\n    \"least_square/householder_reflector.md\",\n    \"least_square/gmres.md\",\n    \"least_square/nolinear_least_square.md\",\n]\nDepth = 3","category":"page"},{"location":"numerical_analysis/least_square/#Index-1","page":"目录","title":"Index","text":"","category":"section"},{"location":"numerical_analysis/least_square/#","page":"目录","title":"目录","text":"Pages   = map(file -> joinpath(\"least_square\", file), readdir(\"least_square\"))","category":"page"},{"location":"numerical_analysis/least_square/gram_schmidt_orthogon/#格拉姆-施密特正交-1","page":"格拉姆-施密特正交","title":"格拉姆-施密特正交","text":"","category":"section"},{"location":"numerical_analysis/least_square/gram_schmidt_orthogon/#","page":"格拉姆-施密特正交","title":"格拉姆-施密特正交","text":"CurrentModule = LeastSquare","category":"page"},{"location":"numerical_analysis/least_square/gram_schmidt_orthogon/#","page":"格拉姆-施密特正交","title":"格拉姆-施密特正交","text":"Pages   = [\"gram_schmidt_orthogon.md\"]","category":"page"},{"location":"numerical_analysis/least_square/gram_schmidt_orthogon/#格拉姆-施密特正交方法-1","page":"格拉姆-施密特正交","title":"格拉姆-施密特正交方法","text":"","category":"section"},{"location":"numerical_analysis/least_square/gram_schmidt_orthogon/#","page":"格拉姆-施密特正交","title":"格拉姆-施密特正交","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :classic_gram_schmidt_orthogon","category":"page"},{"location":"numerical_analysis/least_square/gram_schmidt_orthogon/#LeastSquare.classic_gram_schmidt_orthogon-Tuple{Any,Any}","page":"格拉姆-施密特正交","title":"LeastSquare.classic_gram_schmidt_orthogon","text":"格拉姆-施密特正交方法\n\nclassic_gram_schmidt_orthogon(A, n)\n\n格拉姆-施密特方法是对一组向量正交化。给定一组输入的m维向量，目的是找出正交坐标系统，获取由这些向量张成的空间。\n\n更精确的说，给定n个线性无关的输入向量，该方法将计算出n个彼此正交的单位向量，构成一组单位正交向量。\n\n格拉姆-施密特过程\n\n令a_1 a_2 a_n是R^m中的线性无关向量(nle m)\n\n首先定义：\n\ny_1=a_1 space 与 space q_1 = frac y_1Vert y_1 Vert_2\n\n这样q1是找出的第一个单位向量。为了找到第2个单位向量，对a2在q1方向上的投影减去a2，并对结果规范化:\n\ny_2 = a_2 - q_1(q^T_1a_2) space q_2 = frac y_2Vert y_2 Vert_2\n\ntips：(uv) = v^Tu space (uu) = Vert u Vert^2,uv维数相同\n\n则可以看到:\n\nqquad q^T_1y_2 = q^T_1a_2 - q^T_1a_2 = 0\n\n说明q_1q_2是正交关系\n\n因此定义第j步：\n\ny_j = a_j - q_1(q^T_1a_j) - q_2(q^T_2a_j)-  - q_j-1(q^T_j-1a_j) q_j = fracy_jVert y_j Vert_2\n\n这样的到的q_1q_2q_n两两正交，而且q_1q_2q_n张成的空间和a_1 a_2 a_n的等价     \n\nExample\n\njulia> A = [1 -4; 2 3; 2 2]\n3×2 Array{Int64,2}:\n 1  -4\n 2   3\n 2   2\njulia> classic_gram_schmidt_orthogon(A, 2)\n3×2 Array{Float64,2}:\n 0.3333  -0.9333\n 0.6667   0.3333\n 0.6667   0.1333\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/gram_schmidt_orthogon/#改进的格拉姆-施密特正交方法-1","page":"格拉姆-施密特正交","title":"改进的格拉姆-施密特正交方法","text":"","category":"section"},{"location":"numerical_analysis/least_square/gram_schmidt_orthogon/#","page":"格拉姆-施密特正交","title":"格拉姆-施密特正交","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :gram_schmidt_orthogon","category":"page"},{"location":"numerical_analysis/least_square/gram_schmidt_orthogon/#LeastSquare.gram_schmidt_orthogon-Tuple{Any,Any}","page":"格拉姆-施密特正交","title":"LeastSquare.gram_schmidt_orthogon","text":"改进的格拉姆-施密特正交\n\ngram_schmidt_orthogon(A, n)\n\n对于格拉姆-施密特的微笑改进可以在及其计算中改进精度，改进的格拉姆-施密特正交与前面的原始方法在数学上等价\n\n唯一不同的是内层循环中，a_j被y所替换。本质上它是等价的。\n\nExample\n\njulia> A = [1 1 1; 10^(-10) 0 0 ; 0 10^(-10) 0; 0 0 10^(-10)]\n4×3 Array{Float64,2}:\n 1.0      1.0      1.0    \n 1.0e-10  0.0      0.0    \n 0.0      1.0e-10  0.0    \n 0.0      0.0      1.0e-10\n\njulia> classic_gram_schmidt_orthogon(A, 3)    # 10^-20是一个可接受的双精度值，但在1 + 10^-20 = 1 ，此时精度丢失了\n4×3 Array{Float64,2}:\n 1.0   0.0      0.0   \n 0.0  -0.7071  -0.7071\n 0.0   0.7071   0.0   \n 0.0   0.0      0.7071\n\njulia> gram_schmidt_orthogon(A, 3)    # 这里一定程度避免了1 + 10^-20 这样的情况出现，从而改进了精度，得到准确的值\n4×3 Array{Float64,2}:\n 1.0   0.0      0.0   \n 0.0  -0.7071  -0.4082\n 0.0   0.7071  -0.4082\n 0.0   0.0      0.8165\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_solving/#求解一元方程-1","page":"目录","title":"求解一元方程","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/#","page":"目录","title":"目录","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numerical_analysis/equation_solving/#Content-1","page":"目录","title":"Content","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/#","page":"目录","title":"目录","text":"Pages = [\n    \"equation_solving/bisect.md\",\n    \"equation_solving/fixed_point_iteration.md\",\n    \"equation_solving/newton_method.md\",\n    \"equation_solving/secant.md\",\n]\nDepth = 3","category":"page"},{"location":"numerical_analysis/equation_solving/#Index-1","page":"目录","title":"Index","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/#","page":"目录","title":"目录","text":"Pages   = map(file -> joinpath(\"equation_solving\", file), readdir(\"equation_solving\"))","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/bezier_curve/#贝塞尔曲线-1","page":"贝塞尔曲线","title":"贝塞尔曲线","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/bezier_curve/#","page":"贝塞尔曲线","title":"贝塞尔曲线","text":"CurrentModule = InterpolationPolynomial","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/bezier_curve/#","page":"贝塞尔曲线","title":"贝塞尔曲线","text":"Pages   = [\"bezier_curve.md\"]","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/bezier_curve/#平面贝塞尔样条-1","page":"贝塞尔曲线","title":"平面贝塞尔样条","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/bezier_curve/#","page":"贝塞尔曲线","title":"贝塞尔曲线","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :bezier_curve","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/bezier_curve/#InterpolationPolynomial.bezier_curve-NTuple{4,Any}","page":"贝塞尔曲线","title":"InterpolationPolynomial.bezier_curve","text":"贝塞尔曲线\n\nbezier_curve(p1, p2, p3, p4)\n\n贝塞尔样条是一个允许用户控制节点处斜率的样条。作为额外自由控制的代价，在节点的处的一阶和二阶导数的平滑性不再能保证，而这种平滑性是前面三次样条本身就具有的性质。\n\n贝塞尔样条适合不时出现角点(一阶导数不连续)和曲率突变(二阶导数不连续)的情况\n\n平面贝塞尔样条的每一段由4个点(x_1 y_1)(x_2 y_2)(x_3 y_3)(x_4 y_4)所确定，第一个点和最后一个点称为样条的起点和终点，中间的两个点称为控制点。\n\n曲线以切线方向(x_2-x_1 y_2-y_1)离开(x_1 y_1), 并以切线方向(x_4-x_3 y_4-y_3)在(x_4 y_4)点结束。\n\n满足这些条件的曲线以参数化形式表示为：(x(t) y(t))，其中0 le t le 1\n\nqquad beginaligned x(t) = x_1 + b_xt + c_xt^2 + d_xt^3  y(t) = y_1 + b_yt + c_yt^2 + d_yt^3 endaligned\n\n其中：\n\nqquad beginaligned b_x = 3(x_2 - x_1)  c_x = 3(x_3-x_2) - b_x  d_x = x_4 - x_1 - b_x - c_x  b_y = 3(y_2 - y_1)  c_y = 3(y_3-y_2) - b_y  d_y = y_4 - y_1 - b_y - c_y endaligned\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/interpolation_polynomial/bezier_curve/#绘制平面贝塞尔曲线-1","page":"贝塞尔曲线","title":"绘制平面贝塞尔曲线","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/bezier_curve/#","page":"贝塞尔曲线","title":"贝塞尔曲线","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :bezier_draw","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/bezier_curve/#InterpolationPolynomial.bezier_draw-Tuple{}","page":"贝塞尔曲线","title":"InterpolationPolynomial.bezier_draw","text":"绘制贝塞尔曲线\n\nbezier_draw(A)\n\n返回绘制曲线的横纵坐标\n\n绘制字母T\n\nusing Plots\npyplot()\n\nA = [\n    237,620,237,620,237,120,237,120,\n    237,120,237, 35,226, 24,143, 19,\n    143, 19,143, 19,143,  0,143,  0, \n    143,  0,143,  0,435,  0,435,  0, \n    435,  0,435,  0,435, 19,435, 19, \n    435, 19,353, 23,339, 36,339,109, \n    339,109,339,108,339,620,339,620, \n    339,620,339,620,393,620,393,620, \n    393,620,507,620,529,602,552,492, \n    552,492,552,492,576,492,576,492,\n    576,492,576,492,570,662,570,662,\n    570,662,570,662,  6,662,  6,662,\n      6,662,  6,662,  0,492,  0,492,\n      0,492,  0,492, 24,492, 24,492,\n     24,492, 48,602, 71,620,183,620,\n    183,620,183,620,237,620,237,620\n]\nA = reshape(A, (8,16))\n\nx, y = bezier_draw(transpose(A)\nplot(x, y, title=\"T\")\n\n(Image: )\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/nolinear_least_square/#非线性最小二乘-1","page":"非线性最小二乘","title":"非线性最小二乘","text":"","category":"section"},{"location":"numerical_analysis/least_square/nolinear_least_square/#","page":"非线性最小二乘","title":"非线性最小二乘","text":"CurrentModule = LeastSquare","category":"page"},{"location":"numerical_analysis/least_square/nolinear_least_square/#","page":"非线性最小二乘","title":"非线性最小二乘","text":"Pages   = [\"nolinear_least_square.md\"]","category":"page"},{"location":"numerical_analysis/least_square/nolinear_least_square/#高斯牛顿法-1","page":"非线性最小二乘","title":"高斯牛顿法","text":"","category":"section"},{"location":"numerical_analysis/least_square/nolinear_least_square/#","page":"非线性最小二乘","title":"非线性最小二乘","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :guass_newton","category":"page"},{"location":"numerical_analysis/least_square/nolinear_least_square/#LeastSquare.guass_newton-NTuple{4,Any}","page":"非线性最小二乘","title":"LeastSquare.guass_newton","text":"高斯-牛顿方法\n\nguass_newton(r, Dr, x_0, k)\n\n对于非线性最小二乘问题，可以使用高斯牛顿方法求解。\n\n高斯牛顿方法推导\n\n目的是最小化误差余项的平方和，对于m个方程和n个未知数的方程组，误差为:\n\nqquad beginaligned r_1(x_1 x_2  x_n) = 0     r_m(x_1 x_2  x_n) = 0 endaligned\n\n误差平方和为：\n\nE(x_1  x_n) = frac 12 (r^2_1++r^2_m)\n\n高斯牛顿方法推导源于牛顿法：\n\nE(x)的二阶Taylor展开:\n\nqquad beginaligned E(x) approx E(x_k) + E(x_k)(x-x_k) + frac 12 E(x_k)(x-x_k)^2  endaligned\n\n令Delta x = x - x_k,即x = x_k + Delta x:\n\nqquad beginaligned E(x_k+Delta x) approx E(x_k) + E(x_k)Delta x + frac 12 E(x_k)Delta x^2 endaligned\n\n为了最小化E，也就是极值问题，因此令E的梯度为0:\n\nqquad g(x_k) = nabla E(x_k) = frac ddDelta x(E(x_k) + E(x_k)Delta x + frac 12 E(x_k)Delta x^2) = E(x_k) + E(x_k)Delta x = 0\n\n则有：\n\nDelta x = - frac E(x_k)E(x_k)\n\n由于E是向量函数，这里将x_k+1 = x_k + Delta x改写为\n\nx_k+1 = x_k - H^-1g\n\n其中g为梯度向量，H为海森矩阵\n\nqquad beginaligned g_j = 2sum^m_i=1r_i frac partial r_ipartial x_j = 2sum^m_i=1r_i J_ij qquad  j=12n  h_jk = 2sum^m_i=1(fracpartial r_ipartial x_jfracpartial r_ipartial x_k + fracpartial^2 r_ipartial x_j partial x_k) approx 2sum^m_i=1 J_ij J_ik qquad  jk=12n endaligned\n\n简化为:\n\nqquad beginaligned g = 2J^T_rr  H approx 2J^T_rJ_r endaligned\n\n其中J_r表示雅可比矩阵\n\nx_k+1 = x_k - (J^T_rJ_r)^-1J^T_rr(x_k)\n\n同样为了避免求逆的过程，令HDeltax_k = -g,即J^T_rJ_r Deltax_k = -J^T_rr(x_k)，先求解出Deltax_k, 然后代入x_k+1 = x_k + Deltax_k更新\n\nExample\n\nfunction test_guass_newton()\n    # 找到一点，要求离三个圆的距离的平方和最小\n    # 圆心坐标\n    x1, y1 = -1, 0\n    x2, y2 = 1, 0.5\n    x3, y3 = 1, -0.5\n    # 圆半径\n    r1, r2, r3 = 1, 0.5, 0.5\n    # 误差函数\n    r = [\n        (x,y) -> sqrt((x-x1)^2+ (y-y1)^2) - r1\n        (x,y) -> sqrt((x-x2)^2+ (y-y2)^2) - r2\n        (x,y) -> sqrt((x-x3)^2+ (y-y3)^2) - r3\n    ]\n    # r关于(x,y)的一阶偏导数矩阵\n    Dr = [\n        (x,y) -> (x-x1)/sqrt((x-x1)^2+ (y-y1)^2) (x,y) -> (y-y1)/sqrt((x-x1)^2+ (y-y1)^2);\n        (x,y) -> (x-x2)/sqrt((x-x2)^2+ (y-y2)^2) (x,y) -> (y-y2)/sqrt((x-x2)^2+ (y-y2)^2);\n        (x,y) -> (x-x3)/sqrt((x-x3)^2+ (y-y3)^2) (x,y) -> (y-y3)/sqrt((x-x3)^2+ (y-y3)^2);\n    ]\n    x = round.(guass_newton(r, Dr, [0;0], 10), digits=6)\n    @assert reshape(x, 1,2) == [0.412891 0.0]\n    return \nend\n\njulia> test_guass_newton()\n2×1 Array{Float64,2}:\n 0.412891\n 0.0 \n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/nolinear_least_square/#Levenberg-Marquardt方法-1","page":"非线性最小二乘","title":"Levenberg-Marquardt方法","text":"","category":"section"},{"location":"numerical_analysis/least_square/nolinear_least_square/#","page":"非线性最小二乘","title":"非线性最小二乘","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :levenberg_marquardt","category":"page"},{"location":"numerical_analysis/least_square/nolinear_least_square/#LeastSquare.levenberg_marquardt-NTuple{5,Any}","page":"非线性最小二乘","title":"LeastSquare.levenberg_marquardt","text":"Levenberg Marquardt 方法\n\nlevenberg_marquardt(r, Dr, x_0, k, λ)\n\n对于非线性最小二乘问题中，如果定义好的模型在计算得到了条件数比较差\b的雅可比矩阵的话，往往求出的解会有比较大的误差，因此 Levenberg Marquardt 方法使用了正则化来修复这个问题\n\n其中用lambda diag J^T_rJ_r来强化对角线元素的作用，以改善条件数\n\n(J^T_rJ_r + lambda diag J^T_rJ_r) Deltax_k = -J^T_rr(x_k)\n\n当lambda = 0时，该方法就是高斯牛顿方法。另外lambda通常看作一个常数，但该方法中常常使用不同的lambda以适应问题，一般策略是：\n\n只要余下的平方误差和在每步降低，那么就使用一个因子降低lambda \n如果误差升高，则反之，使用因子升高lambda\n\nExample\n\n使用Levenberg Marquardt将模型y = c_1 e^-c_2(x-c_3)^2拟合到数据点(1,3),(2,5),(2,7),(3,5),(4,1)\n\nfunction test_levenberg_marquardt()\n    points = [\n        (1,3)\n        (2,5)\n        (2,7)\n        (3,5)\n        (4,1)\n    ]\n\n    r = [(c1,c2,c3) -> c1*exp(1)^(-c2*(x-c3)^2)-y for (x,y) in points]\n    f_c1 = [(c1,c2,c3)-> exp(1)^(-c2*(x-c3)^2) for (x,y) in points]\n    f_c2 = [(c1,c2,c3)-> -c1*(x-c3)^2*exp(1)^(-c2*(x-c3)^2) for (x,y) in points]\n    f_c3 = [(c1,c2,c3)-> 2c1*c2*(x-c3)*exp(1)^(-c2*(x-c3)^2) for (x,y) in points]\n    Dr = hcat([f_c1,f_c2,f_c3]...)\n    x = round.(levenberg_marquardt(r, Dr, [1;1;1], 1000, 50), digits=6)\n    # x = round.(levenberg_marquardt(r, Dr, [1;1;1], 1000, 0), digits=6)   无法收敛\n    @assert reshape(x, 1,3) == [6.300046 0.508648 2.248735]\n    return x\nend\n\nλ固定50，迭代1000步的收敛结果：\n\njulia> test_levenberg_marquardt()\n3×1 Array{Float64,2}:\n 6.300046\n 0.508648\n 2.248735\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/interpolation_polynomial/chebyshev_interpolation/#切比雪夫插值-1","page":"切比雪夫插值","title":"切比雪夫插值","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/chebyshev_interpolation/#","page":"切比雪夫插值","title":"切比雪夫插值","text":"CurrentModule = InterpolationPolynomial","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/chebyshev_interpolation/#","page":"切比雪夫插值","title":"切比雪夫插值","text":"Pages   = [\"chebyshev_interpolation.md\"]","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/chebyshev_interpolation/#切比雪夫插值多项式-1","page":"切比雪夫插值","title":"切比雪夫插值多项式","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/chebyshev_interpolation/#","page":"切比雪夫插值","title":"切比雪夫插值","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :chebyshev_interpolation","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/chebyshev_interpolation/#InterpolationPolynomial.chebyshev_interpolation-Tuple{Any,Any,Any}","page":"切比雪夫插值","title":"InterpolationPolynomial.chebyshev_interpolation","text":"切比雪夫插值\n\nchebyshev_interpolation(a,b,n)\n\n切比雪夫插值是一种特定最优的点间距选取方式\n\n切比雪夫插值的动机是在插值区间上，提高对插值误差的最大值的控制\n\n根据插值误差公式，要使其最大值足够小，等价于使(x-x_1)(x-x_2)(x-x_n)这个首一多项式的最大值足够小\n\n切比雪夫多项式\n\n切比雪夫多项式：T_n(x)=cos(n space arccos x)\n\n令y=arccos x:\n\nbeginaligned T_1(x) = x  T_2(x) = cos(2y) = cos^2y-sin^2y = 2x^2-1  T_3(x) = 4x^3 - 3x endaligned\n\n一般地:\n\nbeginaligned T_n+1(x) = cos ny cos y - sin ny sin y  T_n-1(x) = cos ny cos y - sin ny sin (-y)  endaligned\n\n可得： T_n+1(x) + T_n-1(x) = 2cos ny cos y = 2xT_n(x)\n\n切比雪夫多项式递归关系:\n\nT_n+1(x) = 2xT_n(x) - T_n-1(x)\n\n令T_n(x)=0, 当xin -11时，当且仅当narccos x = 奇数fracpi2时成立，则有：\n\nx_i = cos frac (2i-1)pi2ni=12n\n\n此时(x-x_1)(x-x_2)(x-x_n) le frac 12^n-1T_n(x)\n\n即(x-x_1)(x-x_2)(x-x_n)具有最小最大值为frac 12^n-1\n\n切比雪夫插值节点\n\n一般地对于区间ab，通过：\n\n使用frac b-a2因子拉伸点\n然后将点平移到frac b+a2，使得中心移动到[a,b]的中心\n\n则有:\n\nx_i =frac b+a2 + fracb-a2cos frac (2i-1)pi2ni=12n\n\n此时不等式\n\n(x-x_1)(x-x_2)(x-x_n) le frac 12^n-1(fracb-a2)^n\n\n在区间ab上成立\n\nx_i称为切比雪夫根，以切比雪夫根为基点的插值多项式称为切比雪夫插值多项式\n\nExample\n\n# 在[0,pi/2]上取处4个切比雪夫插值点\njulia> chebyshev_interpolation(0,pi/2, 4)\n4-element Array{Float64,1}:\n 1.511011451432306   \n 1.0859570283396214  \n 0.4848392984552752  \n 0.059784875362590584\n\n对龙格函数使用切比雪夫插值\n\nf(x) = 1/(1+12*x^2)\nnd = newton_difference_quotient\nx_1 = chebyshev_interpolation(-1, 1, 15)    # 取15个切比雪夫插值点\nc_1 = nd(x_1, f.(x_1))\nx_2 = chebyshev_interpolation(-1, 1, 30)    # 取30个切比雪夫插值点\nc_2 = nd(x_2, f.(x_2))\n\nx = -1.2:0.1:1.2\n\ns1 = scatter(x_1, f.(x_1), label=\"base point\")\ns2 = scatter(x_2, f.(x_2), label=\"base point\")\n\nplot(\n    plot!(s1, x, [f.(x) horner_rule(length(x_1)-1, c_1, x, x_1)], label=[\"f\" \"f1\"], ylims = (-1,2), yticks=-1:1:2, title=\"15 base point\"),\n    plot!(s2, x, [f.(x) horner_rule(length(x_2)-1, c_2, x, x_2)], label=[\"f\" \"f2\"], ylims = (-1,2), yticks=-1:1:2, title=\"30 base point\")\n)\n\n可以看到在-11上多项式图像的扭动已经消失\n\n(Image: )\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/gmres/#广义最小余项方法(GMRES)-1","page":"广义最小余项方法(GMRES)","title":"广义最小余项方法(GMRES)","text":"","category":"section"},{"location":"numerical_analysis/least_square/gmres/#","page":"广义最小余项方法(GMRES)","title":"广义最小余项方法(GMRES)","text":"CurrentModule = LeastSquare","category":"page"},{"location":"numerical_analysis/least_square/gmres/#","page":"广义最小余项方法(GMRES)","title":"广义最小余项方法(GMRES)","text":"Pages   = [\"gmres.md\"]","category":"page"},{"location":"numerical_analysis/least_square/gmres/#GMRES-1","page":"广义最小余项方法(GMRES)","title":"GMRES","text":"","category":"section"},{"location":"numerical_analysis/least_square/gmres/#","page":"广义最小余项方法(GMRES)","title":"广义最小余项方法(GMRES)","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :gmres","category":"page"},{"location":"numerical_analysis/least_square/gmres/#LeastSquare.gmres-Tuple{Any,Any,Any}","page":"广义最小余项方法(GMRES)","title":"LeastSquare.gmres","text":"广义最小余项方法(GMRES)\n\ngmres(A, b, x_0)\n\n共轭梯度法可以看作一种迭代方法用于求解A为对称方阵的方程组Ax=b的解，但如果A不对称，则不能使用共轭梯度法。\n\n但GMRES方法可用于求解非对称的矩阵A，而且它是求解大规模、稀疏、非对称线性方程组Ax=b的好方法。\n\n在GMRES方法中涉及正交性来进行求解：\n\n在每个迭代过程中使用最小二乘公式，最小化后向误差\n在每步中搜索空间的基被重新正交化以消除病态问题中的不精确\n\nGMRES属于Krylov方法，它依赖精确的Krylov空间计算，该空间是向量 r Ar  A^kr 所张成的空间，，其中r=b-Ax_0。\n\n由于向量A^kr对于大的k倾向一个共有方向，Krylov空间的基必须认真计算，找出Krylov空间精确的基需要正交化方法，例如格拉姆-施密特正交或这豪斯霍尔德反射子方法。 (本实现是基于格拉姆-施密特正交方法)\n\n迭代过程相关公式说明：\n\n矩阵A为ntimes n、 H为k+1times k、Q_k为n times k，大多数情况下，k比n小很多\nx_k = x_add + x_0, x_0为初识估计，x_k为第k步的预估值，x_add为从Q_k中搜索到的用于改进原始估计的量\nx_add = Q_kc\nAQ_k = Q_k+1H_k\n\nbeginaligned qquad 为了最小化Ax=b的余项r  Vert b-A(x_0+x_add) Vert = Vert r-Ax_add Vert  = Vert AQ_kc - r Vert = Vert Q_k+1H_kc - r Vert = Vert H_kc-Q^T_k+1r Vert endaligned\n\n因此算法中后部分会利用最小二乘求解c_k，然后求出x_add\n\n重启GMRES\n\nGMRES方法的变种-重启GMRES，其中一种算法实现思想：如果第k步迭代后没能足够趋近解， 而且ntimes k 的Q_k变得大得难以处理，可以考虑扔掉Q_k，重新开始GMRES方法，并使用当前的最优估计x_k作为新的x_0\n\nExample\n\njulia> gmres([1 1 0; -1 1 2; 0 0 1], [1;0;0], [0.0;0.0;0.0])\n3-element Array{Float64,1}:\n 0.5\n 0.5\n 0.0\njulia> gmres([1 1 0; 0 1 0; 1 1 1], [1;0;0], [0.0;0.0;0.0])\n3-element Array{Float64,1}:\n  1.0\n  0.0\n -1.0\njulia> gmres([0 0 1; 1 0 0; 0 1 0], [1;0;0], [0.0;0.0;0.0])\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/gmres/#预条件GMRES-1","page":"广义最小余项方法(GMRES)","title":"预条件GMRES","text":"","category":"section"},{"location":"numerical_analysis/least_square/gmres/#","page":"广义最小余项方法(GMRES)","title":"广义最小余项方法(GMRES)","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :pre_con_gmres","category":"page"},{"location":"numerical_analysis/least_square/gmres/#LeastSquare.pre_con_gmres-NTuple{4,Any}","page":"广义最小余项方法(GMRES)","title":"LeastSquare.pre_con_gmres","text":"预条件GMRES\n\npre_con_gmres(A, b, x_0, M)\n\n同共轭梯度法类似，使用：\n\nM^-1Ax = M^-1b\n\nM被称为预条件子\n\nExample\n\njulia> pre_con_gmres([1 1 0; -1 1 2; 0 0 1], [1;0;0], [0.0;0.0;0.0], [1 0 0;0 1 0; 0 0 1])\n3-element Array{Float64,1}:\n 0.5\n 0.5\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/gauss_elimination/#高斯消去法-1","page":"高斯消去法","title":"高斯消去法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/gauss_elimination/#","page":"高斯消去法","title":"高斯消去法","text":"CurrentModule = EquationSet","category":"page"},{"location":"numerical_analysis/equation_set/gauss_elimination/#","page":"高斯消去法","title":"高斯消去法","text":"Pages   = [\"gauss_elimination.md\"]","category":"page"},{"location":"numerical_analysis/equation_set/gauss_elimination/#朴素的高斯消去法-1","page":"高斯消去法","title":"朴素的高斯消去法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/gauss_elimination/#","page":"高斯消去法","title":"高斯消去法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :naive_gauss_elimination","category":"page"},{"location":"numerical_analysis/equation_set/gauss_elimination/#EquationSet.naive_gauss_elimination-Tuple{Any,Any,Any}","page":"高斯消去法","title":"EquationSet.naive_gauss_elimination","text":"朴素的高斯消去法\n\nnaive_gauss_elimination(A, b, n)\n\n朴素的高斯消去法求解方程组。高斯方法是求解线性方程组的直接方法。\n\n消去步骤\n注意：消去过程采取j+1:n的方式迭代，完成后应将a[i,j]置为0， 但这里并没有这么做，是因为在后面的步骤中，并没有用到它，所以省去了置为0的过程\n回代步骤\n从底部开始，逐渐向上求解对应的方程\n\n注意：当前实现的算法如果遇到0主元会抛出异常并终止\n\nAx=b\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nn: 方程数\n\nExample\n\njulia> A = [1 2 -1;2 1 -2;-3 1 1]\n3×3 Array{Int64,2}:\n  1  2  -1\n  2  1  -2\n -3  1   1\njulia> b = [3; 3; -6]\n3-element Array{Int64,1}:\n  3\n  3\n -6\njulia> x = naive_gauss_elimination(A,b,3)\n3×1 Array{Float64,2}:\n 3.0\n 1.0\n 2.0\njulia> A    # 其实表示的应是[1 2 -1; 0 -3 0; 0 0 -2]\n3×3 Array{Int64,2}:\n  1   2  -1\n  2  -3   0\n -3   7  -2\njulia> b\n3-element Array{Int64,1}:\n  3\n -3\n -4\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_solving/fixed_point_iteration/#不动点迭代法-1","page":"不动点迭代法","title":"不动点迭代法","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/fixed_point_iteration/#","page":"不动点迭代法","title":"不动点迭代法","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numerical_analysis/equation_solving/fixed_point_iteration/#","page":"不动点迭代法","title":"不动点迭代法","text":"Pages   = [\"fixed_point_iteration.md\"]","category":"page"},{"location":"numerical_analysis/equation_solving/fixed_point_iteration/#不动点迭代法-2","page":"不动点迭代法","title":"不动点迭代法","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/fixed_point_iteration/#","page":"不动点迭代法","title":"不动点迭代法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :fixed_point_iteration","category":"page"},{"location":"numerical_analysis/equation_solving/fixed_point_iteration/#EquationSolving.fixed_point_iteration-Tuple{Any,Any,Any}","page":"不动点迭代法","title":"EquationSolving.fixed_point_iteration","text":"不动点迭代法\n\nfixed_point_iteration(g, x_0, k)\n\n不动点迭代法求解函数值\n\n不动点迭代法迭代公式：\n\nbeginaligned f(x)=g(x)-x  x_0 = 初始估计 x_i+1 = g(x_i)(i=0123) endaligned\n\nArguments\n\ng: g(x)函数\nx_0: 初始估计值\nk: 迭代次数\n\nExample\n\njulia> fixed_point_iteration(x-> cos(x), 0, 100)\n0.7390851332151607\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/interpolation_polynomial/#插值多项式-1","page":"目录","title":"插值多项式","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/#","page":"目录","title":"目录","text":"CurrentModule = InterpolationPolynomial","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/#Content-1","page":"目录","title":"Content","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/#","page":"目录","title":"目录","text":"Pages = [\n    \"interpolation_polynomial/newton_difference_quotient.md\",\n    \"interpolation_polynomial/error_and_runge_phenomenon.md\",\n    \"interpolation_polynomial/chebyshev_interpolation.md\",\n    \"interpolation_polynomial/cubic_spline.md\",\n    \"interpolation_polynomial/bezier_curve.md\",\n]\nDepth = 3","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/#Index-1","page":"目录","title":"Index","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/#","page":"目录","title":"目录","text":"Pages   = map(file -> joinpath(\"interpolation_polynomial\", file), readdir(\"interpolation_polynomial\"))","category":"page"},{"location":"numerical_analysis/equation_solving/secant/#割线方法-1","page":"割线方法","title":"割线方法","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/secant/#","page":"割线方法","title":"割线方法","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numerical_analysis/equation_solving/secant/#","page":"割线方法","title":"割线方法","text":"Pages   = [\"secant.md\"]","category":"page"},{"location":"numerical_analysis/equation_solving/secant/#割线方法-2","page":"割线方法","title":"割线方法","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/secant/#","page":"割线方法","title":"割线方法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :secant","category":"page"},{"location":"numerical_analysis/equation_solving/secant/#EquationSolving.secant-NTuple{4,Any}","page":"割线方法","title":"EquationSolving.secant","text":"割线方法\n\nsecant(f, x_0, x-1, k)\n\n割线方法法计算方程解。\n\n当难以计算函数导数时，割线方法是牛顿迭代法的一个很好的替代。\n割线方法需要提供两个初始估计\n\n割线方法迭代公式\n\nbeginaligned x_0 x_1 = 初始估计值 x_i+1 = x_i - frac f(x_i)(x_i-x_i-1)f(x_i)-f(x_i-1)(i=0123) endaligned\n\nArguments\n\nf: f(x)函数\nx_0: 初始估计值1\nx_1: 初始估计值2\nk: 迭代次数\n\nExample\n\njulia> secant(x->x^3 +x -1, 0, 1, 20)\n0.6823278038280193\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_solving/secant/#试位方法-1","page":"割线方法","title":"试位方法","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/secant/#","page":"割线方法","title":"割线方法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :regula_falsi","category":"page"},{"location":"numerical_analysis/equation_solving/secant/#EquationSolving.regula_falsi-NTuple{4,Any}","page":"割线方法","title":"EquationSolving.regula_falsi","text":"试位方法\n\nregula_falsi(f, a, b, k)\n\n试位方法是割线方法推广，类似二分法，但其中的中点被类似割线方法的近似所替换\n\n试位方法迭代公式\n\nbeginaligned a b = 初始估计值 c = a - frac f(a)(a-b)f(a)-f(b) = frac bf(a)-af(b)f(a)-f(b) endaligned\n\nArguments\n\nf: f(x)函数\na: 初始估计值1\nb: 初始估计值2\nk: 迭代次数\n\nExample\n\njulia> regula_falsi(x->x^3 +x -1, 0, 1, 100)\n0.6823278038280193\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#插值误差和龙格现象-1","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"Pages   = [\"error_and_runge_phenomenon.md\"]","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#插值误差-1","page":"插值误差和龙格现象","title":"插值误差","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"函数y=f(x)，从函数取n点，生成插值多项式P(x)，那么在x_i点的插值误差是f(x_i)-P(x_i)","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#插值误差公式-1","page":"插值误差和龙格现象","title":"插值误差公式","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"f(x)-P(x) = frac (x-x_1)(x-x_2)(x-x_n)nf^(n)(c)","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"c在最小和最大的n+1个数字x_1x_2x_n之间","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#龙格现象-1","page":"插值误差和龙格现象","title":"龙格现象","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"当插值点数量增加，等距离选取插值点会带来收敛困难的问题，这一困难被称为龙格现象。","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"龙格现象的主要特征是：多项式在插值区间的端点附近扭动","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#龙格函数例子-1","page":"插值误差和龙格现象","title":"龙格函数例子","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"f(x) = 1/(1+12*x^2)    # 龙格函数\nnd = newton_difference_quotient\nx_1 = -1:1/7:1\nc_1 = nd(x_1, f.(x_1))\nx_2 = -1:1/14:1\nc_2 = nd(x_2, f.(x_2))\n\nx = -1.2:0.1:1.2\n\ns1 = scatter(x_1, f.(x_1), label=\"base point\")\ns2 = scatter(x_2, f.(x_2), label=\"base point\")\n\nplot(\n    plot!(s1, x, [f.(x) horner_rule(length(x_1)-1, c_1, x, x_1)], label=[\"f\" \"f1\"], ylims = (-1,2), yticks=-1:1:2, title=\"15 base point\"),\n    plot!(s2, x, [f.(x) horner_rule(length(x_2)-1, c_2, x, x_2)], label=[\"f\" \"f2\"], ylims = (-1,2), yticks=-1:1:2, title=\"30 base point\")\n)","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"可以看到在区间-11上多项式图像发生不同程度的扭动","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon/#","page":"插值误差和龙格现象","title":"插值误差和龙格现象","text":"(Image: )","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#三次样条插值-1","page":"三次样条插值","title":"三次样条插值","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#","page":"三次样条插值","title":"三次样条插值","text":"CurrentModule = InterpolationPolynomial","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#","page":"三次样条插值","title":"三次样条插值","text":"Pages   = [\"cubic_spline.md\"]","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#自然三次样条-1","page":"三次样条插值","title":"自然三次样条","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#","page":"三次样条插值","title":"三次样条插值","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :natural_cubic_spline","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#InterpolationPolynomial.natural_cubic_spline","page":"三次样条插值","title":"InterpolationPolynomial.natural_cubic_spline","text":"自然三次样条\n\nnatural_cubic_spline(x, y, k=10)\n\n三次样条\n\n给定n个点(x_1 y_1) (x_2 y_2)(x_n y_n),其中x_i不同，并且升序。通过点(x_1 y_1) (x_2 y_2)(x_n y_n)的三次样条S(x)是一组三次多项式：\n\nqquad beginaligned S_1(x) = y_1 + b_1(x-x_1) + c_1(x-x_1)^2 + d_1(x-x_1)^3 spacespace 在区间x_1 x_2上  S_2(x) = y_2 + b_2(x-x_2) + c_2(x-x_2)^2 + d_2(x-x_2)^3 spacespace 在区间x_2 x_3上    S_n-1(x) = y_n-1 + b_n-1(x-x_n-1) + c_n-1(x-x_n-1)^2 + d_n-1(x-x_n-1)^3 spacespace 在区间x_n-1 x_n上 endaligned\n\n且具有以下性质：\n\n性质1：S_i(x_i) = y_iS_i+1(x_i+1) = y_i+1i=12n-1`\n性质2: S_i-1(x_i) = S_i(x_i)i=2n-1`\n性质3: S_i-1(x_i) = S_i(x_i)i=2n-1`\n\n意即相邻的曲线段在节点上具有相同的1阶、2阶导数\n\n但注意在每一段中，满足这三个性质的三次多项式是无穷多个的。通常需要添加额外的约束条件来将问题域约束到唯一解。\n\n根据性质1,可得出以下n-1个方程:\n\nqquad beginaligned y_2 = S_1(x_2) = y_1 + b_1(x_2-x_1) + c_1(x_2-x_1)^2 + d_1(x_2-x_1)^3     y_n = S_n-1(x_n) = y_n-1 + b_n-1(x_n-x_n-1) + c_n-1(x_n-x_n-1)^2 + d_n-1(x_n-x_n-1)^3 endaligned\n\n根据性质2，可得出以下n-2个方程:\n\nqquad beginaligned 0 = S_1(x_2) - S_2(x_2) = b_1 + 2c_1(x_2-x_1)+3d_1(x_2-x_1)^2 - b_2    0 = S_n-2(x_n-1) - S_n-1(x_n-1) = b_n-2 + 2c_n-2(x_n-1-x_n-2)+3d_n-2(x_n-1-x_n-2)^2 - b_n-1 endaligned\n\n根据性质3，可得出以下n-2个方程:\n\nqquad beginaligned 0 = S_1(x_2) - S_2(x_2) = 2c_1 + 6d_1(x_2-x_1) - 2c_2    0 = S_n-2(x_n-1) - S_n-1(x_n-1) = 2c_n-2 + 6d_n-2(x_n-1-x_n-2) - 2c_n-1 endaligned\n\n共计3n-5个方程、3n-3个系数(bi、ci、d_i)\n\n为了简化方程，引入额外的未知变量c_n = S_n-1(x_n)2,会使计算更简单。同时引入：delta_i = x_i+1-x_i、Delta_i = y_i+1-y_i\n\n则根据性质3的公式：\n\nd_i = fracc_i+1-c_i3delta_i i=12n-1\n\n带入性质1的公式：\n\nb_i = fracDelta_idelta_i - c_idelta_i - d_idelta^2_i = fracDelta_idelta_i - fracdelta_i3(2c_i+c_i+1) i=12n-1\n\n将以上两个公式带入性质2的公式中,则简化处以下n-2个方程：\n\nqquad beginaligned delta_1c_1 + 2(delta_1+delta_2)c_2 + delta_2c_3 = 3(fracDelta_2delta_2 - fracDelta_1delta_1)    delta_n-2c_n-2 + 2(delta_n-2+delta_n-1)c_n-1 + delta_n-1c_n = 3(fracDelta_n-1delta_n-1 - fracDelta_n-2delta_n-2) endaligned\n\n自然三次样条\n\n自然三次样条也就是在性质1~3的基础上添加以下性质：\n\nS_1(x_1)=0\nS_n-1(x_n)=0\n\n将样条的开始和结束端点设定为拐点。类似这种在区间两个端点添加的附加条件，被称为边界条件\n\n自然三次样条的条件可以得到另外两个方程：\n\nS_1(x_1)) = 2c_1 = 0 \nS_n-1(x_n) = c_n = 0\n\n结合三次样条关于c_i的n-2个方程组合为一个针对n个未知量(c_i)的n个方程，写成矩阵形式，可以看到它是一个严格对角占优矩阵，通过它解出c_1  c_n，然后带入分别求解出b_id_i\n\nExample\n\njulia> natural_cubic_spline([0 1 2], [3 -2 1], 10)\n3×3 Array{Float64,2}:\n  2.0  0.0  -7.0\n -2.0  6.0  -1.0\n  0.0  0.0   0.0\n\n\n\n\n\n","category":"function"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#曲率调整三次样条-1","page":"三次样条插值","title":"曲率调整三次样条","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#","page":"三次样条插值","title":"三次样条插值","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :curvature_adjustable_cubic_spline","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#InterpolationPolynomial.curvature_adjustable_cubic_spline","page":"三次样条插值","title":"InterpolationPolynomial.curvature_adjustable_cubic_spline","text":"曲率调整三次样条\n\ncurvature_adjustable_cubic_spline(x, y, r1, rn, k=10)\n\n曲率调整三次样条和自然三次样条的不同之处在于，其中的S_1(x_1)S_n-1(x_n)都是可由用户选择的任意数值，而不在是固定的0。这样在样条的开始和结束端点的曲率由用户来控制。\n\nS_1(x_1) = 2c_1 = r_1 \nS_n-1(x_n) = 2c_n = r_n\n\n\n\n\n\n","category":"function"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#钳制三次样条-1","page":"三次样条插值","title":"钳制三次样条","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#","page":"三次样条插值","title":"三次样条插值","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :clamp_cubic_spline","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#InterpolationPolynomial.clamp_cubic_spline","page":"三次样条插值","title":"InterpolationPolynomial.clamp_cubic_spline","text":"钳制三次样条\n\nclamp_cubic_spline(x, y, v1, vn, k=10)\n\n钳制三次样条和曲率调整三次样条类似，不同的是，它的一阶导数S_1(x_1)S_n-1(x_n)都是可有用户选择的定义的数值。这样在样条的开始和结束端点的斜率由用户来控制。\n\n约束条件\n\nS_1(x_1) = v_1 \nS_n-1(x_n) = v_n\n\n推导\n\n因为\n\nqquad beginaligned S_1(x_1) = b_1  S_n-1(x_n) = b_n-1 + c_n-1delta_n-1 + d_n-1delta^2_n-1 endaligned\n\n可得两个新的方程：\n\nqquad beginaligned 2delta_1c_1 +delta_1c_2 = 3(fracDelta_1delta_1-v_1)  delta_n-1c_n-1 +2delta_n-1c_n = 3(v_n-fracDelta_n-1delta_n-1) endaligned\n\n\n\n\n\n","category":"function"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#抛物线端点三次样条-1","page":"三次样条插值","title":"抛物线端点三次样条","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#","page":"三次样条插值","title":"三次样条插值","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :parabola_endpoint_cubic_spline","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#InterpolationPolynomial.parabola_endpoint_cubic_spline","page":"三次样条插值","title":"InterpolationPolynomial.parabola_endpoint_cubic_spline","text":"抛物线端点三次样条\n\nparabola_endpoint_cubic_spline(x, y, k=10)\n\n约束条件\n\nd_1=0=d_n-1\n\n通过定义d_1=0=d_n-1使得样条的起始和结束部分的S_1和S_n-1至多2阶。\n\n可通过要求c_1=c_2c_n-1=c_n使得约束条件成立\n\n\n\n\n\n","category":"function"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#非纽结三次样条-1","page":"三次样条插值","title":"非纽结三次样条","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#","page":"三次样条插值","title":"三次样条插值","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :unknot_cubic_spline","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#InterpolationPolynomial.unknot_cubic_spline","page":"三次样条插值","title":"InterpolationPolynomial.unknot_cubic_spline","text":"非纽结三次样条\n\nunknot_cubic_spline(x, y, k=10)\n\n约束条件\n\nd_1 = d_2 d_n-2=d_n-1\n\n等价于: S_1x_2 = S_2(x_2) S_n-2(x_n-1)=S_n-1(x_n-1)\n\n可以看到S_1和S_2在x_2的0、1、2、3阶导数均相等，意味着不再将x_2作为基点，在x_1 x_3上S_1=S_2;同理x_n-1不再作为基点，S_n-2=S_n-1\n\n推导\n\nqquad beginaligned d_1=d_2 Rightarrow fracc_2-c_1delta_1 = fracc_3-c_2delta_2   Rightarrow delta_2c_1 - (delta_1+delta_2)c_2 + delta_1c_3=0  d_n-2 = d_n-1 Rightarrow delta_n-1c_n-2 - (delta_n-2 + delta_n-1)c_n-1 + delta_n-2c_n = 0 endaligned\n\n\n\n\n\n","category":"function"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#不同三次样条方法比较-1","page":"三次样条插值","title":"不同三次样条方法比较","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#下面分别是针对x[0-1-2-3-4-5]、y[3-1-4-1-2-0]进行三次样条插值的图像-1","page":"三次样条插值","title":"下面分别是针对x=0 1 2 3 4 5y=3 1 4 1 2 0进行三次样条插值的图像","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#","page":"三次样条插值","title":"三次样条插值","text":"x_0 = [0;1;2;3;4;5]\ny_0 = [3;1;4;1;2;0]\n\nn = length(x_0)\n\nfunction generate_coordinate(coeff)\n    x = []\n    y = []\n    for i = 1:n-1\n        xs = x_0[i]:0.05:x_0[i+1]\n        b, c, d = coeff[i, :]\n        dx = xs.-x_0[i]\n        ys = dx.*d\n        ys = dx.*(ys.+c)\n        ys = dx.*(ys.+b) .+ y_0[i]\n        x = [x;xs]\n        y = [y;ys]\n    end\n    return x, y\nend\n\nx1, y1 = generate_coordinate(natural_cubic_spline(x_0, y_0))\nx2, y2 = generate_coordinate(curvature_adjustable_cubic_spline(x_0, y_0, 10, 10))    # 端点处曲率设置为10\nx3, y3 = generate_coordinate(clamp_cubic_spline(x_0, y_0, 0, 0))    # 端点处斜率设置为0\nx4, y4 = generate_coordinate(parabola_endpoint_cubic_spline(x_0, y_0))\nx5, y5 = generate_coordinate(unknot_cubic_spline(x_0, y_0))\n\nplot(\n    plot!(scatter(x_0, y_0, label=\"base point\"), x1, [y1 y2], title=\"natural/curvature cubic spline\", label=[\"nature\" \"curvature=10\"]),\n    plot!(scatter(x_0, y_0, label=\"base point\"), x3, [y3], title=\"clamp cubic spline\", label=\"clamp\"),\n    plot!(scatter(x_0, y_0, label=\"base point\"), x4, [y4], title=\"parabola endpoint cubic spline\", label=\"parabola\"),\n    plot!(scatter(x_0, y_0, label=\"base point\"), x5, [y5], title=\"unknot cubic spline\", label=\"unknot\")\n)","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/cubic_spline/#","page":"三次样条插值","title":"三次样条插值","text":"(Image: )","category":"page"},{"location":"numerical_analysis/equation_set/lu_factorization/#LU分解-1","page":"LU分解","title":"LU分解","text":"","category":"section"},{"location":"numerical_analysis/equation_set/lu_factorization/#","page":"LU分解","title":"LU分解","text":"CurrentModule = EquationSet","category":"page"},{"location":"numerical_analysis/equation_set/lu_factorization/#","page":"LU分解","title":"LU分解","text":"Pages   = [\"lu_factorization.md\"]","category":"page"},{"location":"numerical_analysis/equation_set/lu_factorization/#LU分解–高斯消去法的矩阵形式-1","page":"LU分解","title":"LU分解–高斯消去法的矩阵形式","text":"","category":"section"},{"location":"numerical_analysis/equation_set/lu_factorization/#","page":"LU分解","title":"LU分解","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :lu_factorization ","category":"page"},{"location":"numerical_analysis/equation_set/lu_factorization/#EquationSet.lu_factorization-Tuple{Any,Any,Any}","page":"LU分解","title":"EquationSet.lu_factorization","text":"LU分解–高斯消去法的矩阵形式\n\nlu_factorization(A, b, n)\n\n将系数矩阵分解为下三角矩阵L和上三角矩阵U，再求解x，可降低运算次数。\n\nLU分解使得在朴素的高斯消元法中的消去过程，向量b没有参与运算，直到回代过程才参与运算(两次)，相比而言，当n非常大时，计算次数会有明显的差异\n\n注意：当前实现的算法如果遇到0主元会抛出异常并终止\n\nLU分解–高斯消去法的矩阵形式推导：\n\nbeginaligned A = LU  Ax =b Longleftrightarrow LUx=b  Lc = b Rightarrow c  Ux =c Rightarrow x endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nn: 方程数\n\nExample\n\njulia> A = Float64[1 2 -1;2 1 -2;-3 1 1]\n3×3 Array{Float64,2}:\n  1.0  2.0  -1.0\n  2.0  1.0  -2.0\n -3.0  1.0   1.0\njulia> b = Float64[3; 3; -6]\n3-element Array{Float64,1}:\n  3.0\n  3.0\n -6.0\njulia> x = lu_factorization(A,b,3)\n3×1 Array{Float64,2}:\n 3.0\n 1.0\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/lu_factorization/#PALU分解–部分主元法-1","page":"LU分解","title":"PA=LU分解–部分主元法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/lu_factorization/#","page":"LU分解","title":"LU分解","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :lu_factorization_with_permutation","category":"page"},{"location":"numerical_analysis/equation_set/lu_factorization/#EquationSet.lu_factorization_with_permutation-Tuple{Any,Any,Any}","page":"LU分解","title":"EquationSet.lu_factorization_with_permutation","text":"PA=LU分解\n\nlu_factorization_with_permutation(A, b, n)\n\n为避免淹没问题，在对矩阵A进行LU分解前，先对主元列进行判断，将主元列最大的一行与当前的首行进行置换\n\nPA=LU分解推导：\n\nbeginaligned P  置换矩阵  A = LU Longleftrightarrow PA=LU endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nn: 方程数\n\nExample\n\njulia> A = Float64[2 1 5; 4 4 -4; 1 3 1]\n3×3 Array{Float64,2}:\n 2.0  1.0   5.0\n 4.0  4.0  -4.0\n 1.0  3.0   1.0\njulia> b = Float64[5; 0; 6]\n3-element Array{Float64,1}:\n 5.0\n 0.0\n 6.0\njulia> x = lu_factorization_with_permutation(A,b,3)\n3×1 Array{Float64,2}:\n -1.0\n  2.0\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_solving/bisect/#二分法-1","page":"二分法","title":"二分法","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/bisect/#","page":"二分法","title":"二分法","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numerical_analysis/equation_solving/bisect/#","page":"二分法","title":"二分法","text":"Pages   = [\"bisect.md\"]","category":"page"},{"location":"numerical_analysis/equation_solving/bisect/#二分法-2","page":"二分法","title":"二分法","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/bisect/#","page":"二分法","title":"二分法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :bisect","category":"page"},{"location":"numerical_analysis/equation_solving/bisect/#EquationSolving.bisect-NTuple{4,Any}","page":"二分法","title":"EquationSolving.bisect","text":"二分法\n\nbisect(fn, a, b, err)\n\n二分法求解方程解\n\nArguments\n\nfn: 函数\na: 左区间点\nb: 右区间点\nerr: 误差\n\nExample\n\njulia> bisect(x->x^3+x-1, 0, 1, 0.00005)\n0.682342529296875\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/interpolation_polynomial/newton_difference_quotient/#牛顿差商-1","page":"牛顿差商","title":"牛顿差商","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/newton_difference_quotient/#","page":"牛顿差商","title":"牛顿差商","text":"CurrentModule = InterpolationPolynomial","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/newton_difference_quotient/#","page":"牛顿差商","title":"牛顿差商","text":"Pages   = [\"newton_difference_quotient.md\"]","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/newton_difference_quotient/#霍纳法则-1","page":"牛顿差商","title":"霍纳法则","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/newton_difference_quotient/#","page":"牛顿差商","title":"牛顿差商","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :horner_rule","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/newton_difference_quotient/#InterpolationPolynomial.horner_rule-NTuple{4,Any}","page":"牛顿差商","title":"InterpolationPolynomial.horner_rule","text":"霍纳法则\n\nhorner_rule(degree, constants, x, base_points)\n\n对多项式求值的霍纳法则(嵌套乘法)\n\nc_1 + (x-r_1)(c_2+(x-r_2)(c_3 + (x-r_3)(c_4+ (x-r_4)c_5)))\n\nArguments\n\ndegree: 多项式的阶\nconstants: degree+1个系数数组，分别是x^0x^1x^n项的系数\nx::Real: 进行求值带入的x\nbase_points: 每一阶的x的基点数组\n\nUsage\n\njulia> horner_rule(4, [-1 5 -3 3 2], 1/2, [0 0 0 0])\n1.25\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/interpolation_polynomial/newton_difference_quotient/#牛顿差商-2","page":"牛顿差商","title":"牛顿差商","text":"","category":"section"},{"location":"numerical_analysis/interpolation_polynomial/newton_difference_quotient/#","page":"牛顿差商","title":"牛顿差商","text":"Modules = [InterpolationPolynomial]\nFilter = f -> nameof(f) == :newton_difference_quotient","category":"page"},{"location":"numerical_analysis/interpolation_polynomial/newton_difference_quotient/#InterpolationPolynomial.newton_difference_quotient-Tuple{Any,Any}","page":"牛顿差商","title":"InterpolationPolynomial.newton_difference_quotient","text":"牛顿差商方法\n\nnewton_difference_quotient(x, y)\n\n牛顿差商给出插值多项式的一种简单形式。给定n个数据点，所得到的结果多项式至多n-1阶\n\n牛顿差商公式定义：\n\n用fx_1  x_n表示(唯一)多项式的下x^n-1项的系数，该多项式的插值(x_1 f(x_1))(x_n f(x_n))\n\nbeginaligned P(x) =  fx_1 + fx_1 x_2(x-x_1) + fx_1 x_2 x_3(x-x_1)(x-x_2)  + fx_1 x_2 x_3 x_4(x-x_1)(x-x_2)(x-x_3)  +  + fx_1  x_n(x-x_1)(x-x_n-1) endaligned\n\n根据唯一性，x_1 x_2  x_n的任意置换结果相同：\n\nfx_1 x_2  x_n = fx_2 x_3  x_n x_1 = fx_2 x_3 x_n-1 x_1 x_n\n\n由此可推导出:\n\nfx_1  x_k = frac fx_2  x_k - fx_1  x_k-1x_k - x_1\n\n以及：\n\nbeginaligned fx_k = f(x_k)  fx_k x_k+1 = frac fx_k+1-fx_kx_k+1- x_k  fx_k x_k+1  x_k+j = frac fx_k+1  x_k+j-fx_k  x_k+j-1x_k+j- x_k endaligned\n\nExample\n\njulia> x = [0 2 3]\n1×3 Array{Int64,2}:\n 0  2  3\njulia> y = [1 2 4]\n1×3 Array{Int64,2}:\n 1  2  4\njulia> newton_difference_quotient(x,y)\n3-element Array{Float64,1}:\n 1.0\n 0.5\n 0.5\n\nx_0 = [0 2 3]\ny_0 = [1 2 4]\nc = newton_difference_quotient(x_0, y_0)\n\nx = 0:0.01:4\ny = horner_rule(2, c, x, x_0)\n\np = scatter(x_0, y_0, label=\"base point\")\nplot!(p, x, y, label=\"2 degree curve\")\n\n(Image: )\n\n使用牛顿差商在-pi2 pi2近似拟合sin函数\n\n取x=-pi2 -pi4 0 pi4 pi2的插值\n\nx_0 = [-pi/2 -pi/4 0 pi/4 pi/2]\ny_0 = sin.(x_0)\nc = newton_difference_quotient(x_0,y_0)\n\nx = -pi:0.01:pi\ny = horner_rule(length(x_0)-1, c, x, x_0)\n\np = plot(x, [sin.(x) y], label=[\"sin\" \"near curve\"])\nplot!(p, x_0, y_0, shape=:circle, label=\"base point\")\n\n(Image: )\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/normal_equation/#最小二乘与法线方程-1","page":"最小二乘与法线方程","title":"最小二乘与法线方程","text":"","category":"section"},{"location":"numerical_analysis/least_square/normal_equation/#","page":"最小二乘与法线方程","title":"最小二乘与法线方程","text":"CurrentModule = LeastSquare","category":"page"},{"location":"numerical_analysis/least_square/normal_equation/#","page":"最小二乘与法线方程","title":"最小二乘与法线方程","text":"Pages   = [\"normal_equation.md\"]","category":"page"},{"location":"numerical_analysis/least_square/normal_equation/#法线方程-1","page":"最小二乘与法线方程","title":"法线方程","text":"","category":"section"},{"location":"numerical_analysis/least_square/normal_equation/#","page":"最小二乘与法线方程","title":"最小二乘与法线方程","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :normal_equation","category":"page"},{"location":"numerical_analysis/least_square/normal_equation/#LeastSquare.normal_equation-Tuple{Any,Any}","page":"最小二乘与法线方程","title":"LeastSquare.normal_equation","text":"最小二乘与法线方程\n\n最小二乘\n\n求解方程时，有可能方程的个数超过未知变量个数或方程本身不存在解时，可以通过最小二乘近似找到第二可能好的解\n在寻找多项式，并精确拟合数据点时，如果有大量的数据点，或者采集的数据点具有一定误差，使用高阶多项式精确拟合一般不是一个好方法。此时使用简单模型近似拟合数据是一种更合理的方式\n\n在方程无解的情况下，可以通过一种直接方法找到最接近的x，这个特殊的x称为最小二乘解，我们这里把它记为: overlinex\n\n也就是说Aoverlinex neq b但最接近b，等价于：b-Aoverlinex与平面lbrace Axxin R^n rbrace\n\n法线方程\n\n最小二乘基于正交。从平面外一点到一个平面的最短距离，有一个到平面的线段表示。法线方程可以确定该线段，它表示着最小二乘的误差。\n\n已知：(b-Aoverlinex)perp lbrace Axxin R^n rbrace\n\n将垂直性表示为矩阵的乘法，则可以发现对于R^n上的所有x:\n\nqquad beginaligned (Ax)^T(b-Aoverlinex) = 0  x^TA^T(b-Aoverlinex) = 0 endaligned\n\n这也就意味着n维向量A^T(b-Aoverlinex)与中的其他维向量垂直，并且好包括自身，当且仅当:\n\nA^T(b-Aoverlinex) = 0\n\n即：\n\nA^TAoverlinex = A^Tb\n\n这个方程组被称为法线方程，它的解overlinex是方程组Ax=b的最小二乘解。它可以最小化余项r=b-Ax的欧式长度。\n\n如果余项是0向量，那么意味着精确求解了Ax=b。否则余项向量的欧式长度是后向误差，它度量了overlinex到解的距离\n\nqquad beginaligned Vert r Vert_2 = sqrtr^2_1 +  + r^2_m2范数  SE = r^2_1 +  + r^2_m平方误差  RMSE = sqrtfracSEm = sqrtr^2_1 +  + r^2_m均方根误差 endaligned\n\n使用法线方程求解最小二乘问题\n\nA = Float64[1 -4; 2 3; 2 2]\nb = Float64[-3;15;9]\nx = round.(normal_equation(A, b), digits=2)\n# [3.8; 1.8]\nr = round.(b-A*x, digits=2)\n# [0.4; 2.0; -2.2]\nusing LinearAlgebra\nnorm(r)\n# 3.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/normal_equation/#最小二乘数据拟合-1","page":"最小二乘与法线方程","title":"最小二乘数据拟合","text":"","category":"section"},{"location":"numerical_analysis/least_square/normal_equation/#","page":"最小二乘与法线方程","title":"最小二乘与法线方程","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :fit_modeling_by_normal_equation","category":"page"},{"location":"numerical_analysis/least_square/normal_equation/#LeastSquare.fit_modeling_by_normal_equation-Tuple{Any,Any,Any}","page":"最小二乘与法线方程","title":"LeastSquare.fit_modeling_by_normal_equation","text":"最小二乘线性建模\n\n最小二乘建模：使用最小二乘对数据进行模型拟合\n\n最小二乘核心思想：在数据点上通过平方误差度量拟合的余项，并找出模型的参数使得该误差最小\n\n法线方程拟合数据\n\n拟合数据点：(-1, 1)、(0, 0)、(1, 0)、(2, -2)\n\njulia> x = [-1;0;1;2]\n4-element Array{Int64,1}:\n -1\n  0\n  1\n  2\njulia> y = [1;0;0;-2]\n4-element Array{Int64,1}:\n  1\n  0\n  0\n -2\njulia> fit_modeling_by_normal_equation([x.^0 x], x, y)    # 最优直线y = 0.2 - 0.9x\nRMSE: 0.4183\n2-element Array{Float64,1}:\n  0.2\n -0.9\njulia> fit_modeling_by_normal_equation([x.^0 x x.^2], x, y)    # 最优抛物线y=0.45 - 0.65x - 0.25x^2\nRMSE: 0.3354\n3-element Array{Float64,1}:\n  0.45\n -0.65\n -0.25\n\n周期数据拟合\n\njulia> t = 0:1/8:7/8\n0.0:0.125:0.875\n\njulia> y = [-2.2; -2.8; -6.1; -3.9; 0.0;1.1;-0.6;-1.1]\n8-element Array{Float64,1}:\n -2.2\n -2.8\n -6.1\n -3.9\n  0.0\n  1.1\n -0.6\n -1.1\n\njulia> fit_modeling_by_normal_equation([t.^0 cos.(t.*2pi) sin.(t.*2pi)], t, y)    # 模型： y = c1 + c2*cos2πt + c3*sin2πt\nRMSE: 1.0631\n3-element Array{Float64,1}:\n -1.95  \n -0.7445\n -2.5594\n\njulia> fit_modeling_by_normal_equation([t.^0 cos.(t.*2pi) sin.(t.*2pi) cos.(t.*4pi) sin.(t.*4pi)], t, y)    # 模型： y = c1 + c2*cos2πt + c3*sin2πt + c4*cos4πt + c5*sin4πt\nRMSE: 0.3962\n5-element Array{Float64,1}:\n -1.95  \n -0.7445\n -2.5594\n  1.125 \n  0.825\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/iteration_method/#迭代方法-1","page":"迭代方法","title":"迭代方法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"CurrentModule = EquationSet","category":"page"},{"location":"numerical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"Pages   = [\"iteration_method.md\"]","category":"page"},{"location":"numerical_analysis/equation_set/iteration_method/#雅可比方法-1","page":"迭代方法","title":"雅可比方法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :jacobi","category":"page"},{"location":"numerical_analysis/equation_set/iteration_method/#EquationSet.jacobi-NTuple{5,Any}","page":"迭代方法","title":"EquationSet.jacobi","text":"雅可比方法\n\njacobi(A, b, x_0, n, k)\n\n雅可比方法是方程组系统中的一种形式的不动点迭代。在FPI中第一步是重写方程，进而求解未知量。\n\n雅可比方法中，是如下步骤：\n\n求解第i个方程得到第i个未知变量\n然后使用不动点迭代，从初始估计开始，进行迭代\n\n如果矩阵A是严格对角占优矩阵(主对角线的值在其所在行是最大的)，那么A是非奇异矩阵，且对于所有的向量b和初始估计，对Ax=b应用雅可比方法都会收敛到(唯一)解\n\n下式中：\n\nD表示A的主对角线矩阵\nL表示A的下三角矩阵(主对角线以下的元素)\nU表示A的上三角矩阵(主对角线以上的元素)\n\nbeginaligned Ax = b Longleftrightarrow (L+D+U)x = b  Dx = b-(L+U)x  x = D^-1(b-(L+U)x) endaligned\n\n雅可比方法迭代公式：\n\nbeginaligned x_0 = 初始估计  x_k+1 = D^-1(b-(L+U)x_k) k=012 endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nx_0: 初始估计(向量)\nn: 方程数\nk: 迭代次数\n\nExample\n\njulia> A = Float64[3 1; 1 2]\n2×2 Array{Float64,2}:\n 3.0  1.0\n 1.0  2.0\njulia> b = Float64[5; 5]\n2-element Array{Float64,1}:\n 5.0\n 5.0\njulia> x = jacobi(A,b,[0;0], 2, 100)\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/iteration_method/#高斯-赛德尔方法-1","page":"迭代方法","title":"高斯-赛德尔方法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :gauss_seidel","category":"page"},{"location":"numerical_analysis/equation_set/iteration_method/#EquationSet.gauss_seidel-NTuple{5,Any}","page":"迭代方法","title":"EquationSet.gauss_seidel","text":"高斯-赛德尔方法\n\ngauss_seidel(A, b, x_0, n, k)\n\n高斯-赛德尔方法和雅可比方法非常相似，唯一的差异的在于，高斯-赛德尔方法在每一步中都会用到最近更新的未知变量的值。\n\n同样如果矩阵A是严格对角占优矩阵(主对角线的值在其所在行是最大的)，那么A是非奇异矩阵，且对于所有的向量b和初始估计，对Ax=b应用高斯-赛德尔方法都会收敛到(唯一)解\n\n下式中：\n\nD表示A的主对角线矩阵\nL表示A的下三角矩阵(主对角线以下的元素)\nU表示A的上三角矩阵(主对角线以上的元素)\n\nAx = b Longleftrightarrow (L+D)x_k+1 = b - Ux_k\n\n高斯-赛德尔方法迭代公式：\n\nqquad beginaligned x_0 = 初始估计  x_k+1 = D^-1(b-Lx_k+1-Ux_k) k=012 endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nx_0: 初始估计(向量)\nn: 方程数\nk: 迭代次数\n\nExample\n\njulia> A = Float64[3 1 -1; 2 4 1; -1 2 5]\n3×3 Array{Float64,2}:\n  3.0  1.0  -1.0\n  2.0  4.0   1.0\n -1.0  2.0   5.0\njulia> b = Float64[4; 1; 1]\n3-element Array{Float64,1}:\n 4.0\n 1.0\n 1.0\njulia> x_0 = Float64[0;0;0]\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\njulia> x = gauss_seidel(A, b, x_0, 3, 50)    # 该例中约50步收敛\n3-element Array{Float64,1}:\n  2.0\n -1.0\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/iteration_method/#连续过松弛方法-1","page":"迭代方法","title":"连续过松弛方法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/iteration_method/#","page":"迭代方法","title":"迭代方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :sor","category":"page"},{"location":"numerical_analysis/equation_set/iteration_method/#EquationSet.sor","page":"迭代方法","title":"EquationSet.sor","text":"连续过松弛(SOR)\n\nsor(A, b, x_0, n, k, ω=1.25)\n\n连续过松弛方法使用高斯-赛德尔方法的求解方向，并使用过松弛以加快收敛速度。\n\n令omega是一个实数，将新的估计中的每个元素x_k+1定义为omega乘上高斯-赛德尔公式和`1-\\omega乘上当前估计的平均。\n\nomega被称为松弛参数，当omega1时被称为过松弛。\n\n当omega=1时，SOR方法就是高斯-赛德尔方法\n\n连续过松弛(SOR)迭代公式：\n\nbeginaligned x_0 = 初始估计  x_k+1 = (1-omega)x_k + omega D^-1(b-Lx_k+1-Ux_k) k=012 endaligned\n\nArguments\n\nA: 表示系数矩阵A\nb: 表示常数项b\nx_0: 初始估计(向量)\nn: 方程数\nk: 迭代次数\nω: 松弛参数(default=1.25)\n\nExample\n\njulia> A = Float64[3 1 -1; 2 4 1; -1 2 5]\n3×3 Array{Float64,2}:\n  3.0  1.0  -1.0\n  2.0  4.0   1.0\n -1.0  2.0   5.0\njulia> b = Float64[4; 1; 1]\n3-element Array{Float64,1}:\n 4.0\n 1.0\n 1.0\njulia> x_0 = Float64[0;0;0]\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\njulia> x = sor(A, b, x_0, 3, 50, 1.25)    # 该例中约30步收敛\n3-element Array{Float64,1}:\n  2.0\n -1.0\n  1.0\n\n\n\n\n\n","category":"function"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#用于对称正定矩阵的方法-1","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"CurrentModule = EquationSet","category":"page"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Pages   = [\"methods_about_SPD_matrix.md\"]","category":"page"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#楚列斯基分解法-1","page":"用于对称正定矩阵的方法","title":"楚列斯基分解法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :cholesky_decomposition ","category":"page"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#EquationSet.cholesky_decomposition-Tuple{Any,Any}","page":"用于对称正定矩阵的方法","title":"EquationSet.cholesky_decomposition","text":"楚列斯基分解\n\ncholesky_decomposition(A, n)\n\n楚列斯基分解定理：A是n times n对称正定矩阵，则存在上三角矩阵R满足A=R^TR\n\nA = left  beginmatrix a  b  b  c endmatrix right  = left  beginmatrix sqrta  0  fracbsqrta  sqrtc-b^2a endmatrix right  left  beginmatrix sqrta  fracbsqrta  0  sqrtc-b^2a endmatrix right =R^TR\n\n对于对称正定矩阵A，求解Ax=b，和LU分解方式相同：\n\nR^Tc=b Longrightarrow c  Rx=c Longrightarrow x\n\n这样针对对称正定矩阵的方程组求解，等于降低了一般的计算代价来实现。\n\nExample\n\njulia> A = Float64[4 -2 2;-2 2 -4; 2 -4 11]\n3×3 Array{Float64,2}:\n  4.0  -2.0   2.0\n -2.0   2.0  -4.0\n  2.0  -4.0  11.0\njulia> R = cholesky_decomposition(A, 3)\n3×3 Array{Float64,2}:\n 2.0  -1.0   1.0\n 0.0   1.0  -3.0\n 0.0   0.0   1.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#共轭梯度方法-1","page":"用于对称正定矩阵的方法","title":"共轭梯度方法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :conjugate_gradient ","category":"page"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#EquationSet.conjugate_gradient-NTuple{4,Any}","page":"用于对称正定矩阵的方法","title":"EquationSet.conjugate_gradient","text":"共轭梯度方法\n\nconjugate_gradient(A, b, x_0, n)\n\n矩阵A是对称正定ntimes n矩阵，b neq 0是一个向量。\n\n共轭梯度方法公式：\n\n令alpha_k = fracr^T_kr_kd^T_kAd_k\n令beta_k = fracr^T_k+1r_k+1r^T_kr_k\n\nbeginaligned x_0 = 初始估计  d_0 = r_0 = b-Ax_0  x_k+1 = x_k + alpha_k d_k  r_k+1 = r_k - alpha_k A d_k  d_k+1 = r_k+1 + beta_k d_k endaligned\n\n当r_k=0时，方程便得以求解\n\n共轭梯度方法需要在每一步更新三个向量：\n\nx_k: 表示第k步的近似解。\n更新公式：x_k+1 = x_k + alpha_k d_k`\nr_k: 表示近似解x_k的余项。\n更新公式：r_k+1 = r_k - alpha_k A d_k\nd_k: 表示用于更新x_k得到改进的x_k+1时，所使用的新的搜索方向。\n更新公式：d_k+1 = r_k+1 + beta_k d_k\n\n共轭梯度方法成功的关键：\n\n所有的余项r_k两两正交: r^T_kr_j = 0jk\n方向d_k两两A共轭: d^T_k A d_j = 0jk\n\n同时为了保证下一个余项向量与前面所有余项向量都正交\n\n余项r_k+1和方向d_k是正交的\nr_j和方向d_k是A共轭的(j<k)\n\n关于alpha_k的推导:\n\n需要精确alpha_k使得新的余项r_k+1和方向d_k正交\n\nbeginaligned x_k+1 = x_k + alpha_k d_k  b-Ax_k+1 = b-Ax_k - alpha_k A d_k  r_k+1 = r_k - alpha_k A d_k  0 = d^T_kr_k+1 = d^T_k r_k- alpha_k d^T_k A d_k  alpha_k = fracd^T_kr_kd^T_kAd_k endaligned\n\n因为r_k和方向d_k-1是正交\n\nbeginaligned d_k-r_k = beta_k-1d_k-1  r^T_kd_k - r^T_kr_k = 0 endaligned\n\n可得alpha_k = fracr^T_kr_kd^T_kAd_k\n\n关于beta_k的推导:\n\nbeginaligned d_k+1 = r_k+1 + beta_k d_k  0 = d^T_k A d_k+1 = d^T_kAr_k+1 +beta_k d^T_kAd_k  beta_k = -fracd^T_kAr_k+1d^T_kAd_k endaligned\n\n因为余项向量两两正交\n\nbeginaligned r_k+1 = r_k - alpha_k A d_k  r^T_jr_k+1 = r^T_jr_k - alpha_k r^T_j A d_k = 0  fracr^T_jr_kr^T_kr_k = - fracr^T_j A d_kd^T_kAd_k endaligned\n\n对于j=k+1\n\nbeta_k = -fracd^T_kAr_k+1d^T_kAd_k = fracr^T_k+1r_k+1r^T_kr_k\n\nExample\n\njulia> A = [2 2; 2 5]\n2×2 Array{Int64,2}:\n 2  2\n 2  5\njulia> b = [6;3]\n2-element Array{Int64,1}:\n 6\n 3\njulia> x = conjugate_gradient(A, b, [0;0], 2)\n2-element Array{Float64,1}:\n  4.0\n -0.9999999999999993\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#预条件共轭梯度方法-1","page":"用于对称正定矩阵的方法","title":"预条件共轭梯度方法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :conjugate_gradient_with_pre_condition ","category":"page"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#EquationSet.conjugate_gradient_with_pre_condition-NTuple{5,Any}","page":"用于对称正定矩阵的方法","title":"EquationSet.conjugate_gradient_with_pre_condition","text":"预条件共轭梯度方法\n\nconjugate_gradient_with_pre_condition(A, b, x_0, n)\n\n共轭梯度法在病态矩阵上性能很差，可以通过预条件来得到缓解。主要是将问题转化为良态矩阵系统然后再实施共轭梯度法。\n\n矩阵A是对称正定ntimes n矩阵，b neq 0是一个向量。\n\n预条件形式：\n\nM^-1Ax = M^-1b\n\n其中M是可逆的n times n矩阵，称为预条件因子。矩阵M应满足：\n\n与矩阵A足够接近\n容易求逆\n\n但是和矩阵A最接近的是A自身，使用M=A会把问题条件数变为1，但是一般A不容易求逆。而最容易求逆的矩阵是单位矩阵，但它又不能减低条件数。\n\n因此最完美的预条件矩阵位于两者的中间，同时具备二者的性质。\n\n一种特别简单的方式是雅可比预条件子M=D（D是A的对角线矩阵）\n\n预条件共轭梯度方法公式：\n\n令alpha_k = fracr^T_kz_kd^T_kAd_k\n令beta_k = fracr^T_k+1z_k+1r^T_kz_k\n\nbeginaligned x_0 = 初始估计  d_0 = r_0 = b-Ax_0  x_k+1 = x_k + alpha_k d_k  r_k+1 = r_k - alpha_k A d_k  z_k+1 = M^-1r_k+1  d_k+1 = z_k+1 + beta_k d_k endaligned\n\n当r_k=0时，x_k就是方程组的解\n\n预条件共轭梯度方法需要在每一步更新四个向量：\n\nx_k: 表示第k步的近似解。\n更新公式：x_k+1 = x_k + alpha_k d_k`\nr_k: 表示近似解x_k的余项。\n更新公式：r_k+1 = r_k - alpha_k A d_k\nz_k: 表示预条件系统的余项。z_k = M^-1b - M^-1Ax_k = m^-1r_k\n更新公式：z_k+1 = M^-1r_k+1\nd_k: 表示用于更新x_k得到改进的x_k+1时，所使用的新的搜索方向。\n更新公式：d_k+1 = z_k+1 + beta_k d_k\n\nExample\n\njulia> using LinearAlgebra\n\njulia> A = [1 -1 0; -1 2 1; 0 1 2]\n3×3 Array{Int64,2}:\n  1  -1  0\n -1   2  1\n  0   1  2\njulia> b = [0;2;3]\n3-element Array{Int64,1}:\n 0\n 2\n 3\njulia> M = diagm(diag(A))    # 雅可比预条件子\n3×3 Array{Int64,2}:\n 1  0  0\n 0  2  0\n 0  0  2\njulia> x = conjugate_gradient_with_pre_condition(A, b, [0;0;0], 3, M)\n3-element Array{Float64,1}:\n 0.9999999999999996\n 0.9999999999999998\n 0.9999999999999999\n\njulia> A = [1 -1 0; -1 2 1; 0 1 5]\n3×3 Array{Int64,2}:\n  1  -1  0\n -1   2  1\n  0   1  5\njulia> b = [3;-3;4]\n3-element Array{Int64,1}:\n  3\n -3\n  4\njulia> M = diagm(diag(A))    # 雅可比预条件子\n3×3 Array{Int64,2}:\n 1  0  0\n 0  2  0\n 0  0  5\njulia> x = conjugate_gradient_with_pre_condition(A, b, [0;0;0], 3, M)\n3-element Array{Float64,1}:\n  1.9999999999999996\n -1.0\n  0.9999999999999999\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#使用对称连续过松弛(SSOR)预条件子的共轭梯度法-1","page":"用于对称正定矩阵的方法","title":"使用对称连续过松弛(SSOR)预条件子的共轭梯度法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#","page":"用于对称正定矩阵的方法","title":"用于对称正定矩阵的方法","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :ssor ","category":"page"},{"location":"numerical_analysis/equation_set/methods_about_SPD_matrix/#EquationSet.ssor","page":"用于对称正定矩阵的方法","title":"EquationSet.ssor","text":"对称连续过松弛(SSOR)预条件共轭梯度法\n\nssor(A, b, x_0, n, ω=1)\n\nM = (D + omega L)D^-1 (D + omega U)\n\n同SOR方法中，A = L+D+U，omega是0和2之间的常数。\n\n当omega =1时，它也被称为高斯-塞德尔预条件子\n\nbeginaligned M = (D + omega L)D^-1 (D + omega U)  M = (I + omega LD^-1) (D + omega U)  z = M^-1v  Mz = v   (I + omega LD^-1)c = v   (D + omega U)z = c endaligned\n\n对于稀疏矩阵，两次回代所花的时间和非零元素的个数成正比\n\n\n\n\n\n","category":"function"},{"location":"numerical_analysis/least_square/householder_reflector/#豪斯霍尔德反射方法-1","page":"豪斯霍尔德反射方法","title":"豪斯霍尔德反射方法","text":"","category":"section"},{"location":"numerical_analysis/least_square/householder_reflector/#","page":"豪斯霍尔德反射方法","title":"豪斯霍尔德反射方法","text":"CurrentModule = LeastSquare","category":"page"},{"location":"numerical_analysis/least_square/householder_reflector/#","page":"豪斯霍尔德反射方法","title":"豪斯霍尔德反射方法","text":"Pages   = [\"householder_reflector.md\"]","category":"page"},{"location":"numerical_analysis/least_square/householder_reflector/#豪斯霍尔德反射子-1","page":"豪斯霍尔德反射方法","title":"豪斯霍尔德反射子","text":"","category":"section"},{"location":"numerical_analysis/least_square/householder_reflector/#","page":"豪斯霍尔德反射方法","title":"豪斯霍尔德反射方法","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :householder_reflector","category":"page"},{"location":"numerical_analysis/least_square/householder_reflector/#LeastSquare.householder_reflector-Tuple{Any,Any}","page":"豪斯霍尔德反射方法","title":"LeastSquare.householder_reflector","text":"豪斯霍尔德反射子\n\nhouseholder_reflector(x, ω)\n\n尽管改进的格拉姆-施密特正交是计算矩阵的QR分解的有效方式，但它还是不是最好的方式。\n\n豪斯霍尔德反射方法是更好的一种方法，它需要更少的计算，同时在舍入误差放大的意义上将也更稳定。\n\n豪斯霍尔德反射子是一个正交矩阵，它通过m-1维平面反射m维向量\n\n假设x和omega是具有相同欧几里得长度的向量，Vert x Vert_2 = Vert omega Vert_2,则omega - x和omega + x正交\n\n定义向量v = omega - x，考虑投影矩阵：\n\nP = frac vv^Tv^Tv\n\n投影矩阵性质: \n\nqquad P^ - 2 = P\n\nqquad Pv = v\n\n令H = I - 2P，则根据v = omega - x和omega + x正交，可证\n\nHx = Ix - 2Px = omega - v -2frac vv^Tv^Tvx = omega - frac vv^Tv^Tv(omega + x) = omega\n\n矩阵H被称为豪斯霍尔德反射子，且H是对称并正交的矩阵:\n\nqquad H^TH = HH = (I-2P)(I-2P)=I-4P+4P^2 = I\n\nExample\n\njulia> x = [3;4]\n2-element Array{Int64,1}:\n 3\n 4\n\njulia> ω = [5;0]\n2-element Array{Int64,1}:\n 5\n 0\n\njulia> householder_reflector(x,ω)\n2×2 Array{Float64,2}:\n 0.6   0.8\n 0.8  -0.6\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/householder_reflector/#豪斯霍尔德反射子与QR分解-1","page":"豪斯霍尔德反射方法","title":"豪斯霍尔德反射子与QR分解","text":"","category":"section"},{"location":"numerical_analysis/least_square/householder_reflector/#","page":"豪斯霍尔德反射方法","title":"豪斯霍尔德反射方法","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :qr_by_householder_reflector","category":"page"},{"location":"numerical_analysis/least_square/householder_reflector/#LeastSquare.qr_by_householder_reflector-Tuple{Any}","page":"豪斯霍尔德反射方法","title":"LeastSquare.qr_by_householder_reflector","text":"豪斯霍尔德反射子与QR分解\n\nqr_by_householder_reflector(A)\n\n豪斯霍尔德反射子可以用于推导QR分解的一个新的方法。而且该方法是典型矩阵进行QR分解的常用方法。\n\n思想：将列向量x移动到坐标轴，并以此将0放在矩阵中。\n\n一开始令x_1是A的第一列，令omega = pm (Vert x_1 Vert_2 000)为第一个坐标轴上的向量，它们的欧几里得擦和高难度相同（理论上那种符号都可以，但为了数值稳定，一般将x的第一个元素选为正号，以避免两个近似相等的数字相减）\n\n然后生成豪斯霍尔德反射子H_1并满足H_1x= omega。\n\n这是对于H_1A矩阵的第一列除第一个元素外都是0，现在继续这种方式生成H_2H_3,直到将A变为上三角，这样也就得到了R`矩阵。同时有(对于4x3的矩阵A)：\n\nH_3H_2H_1A = R\n\n由于豪斯霍尔德反射子是对称正交矩阵，则有：\n\nA = H_1H_2H_3R \n\n也就是说Q = H_1H_2H_3,则实现了A=QR分解\n\n#Example\n\njulia> A = [1 -4; 2 3; 2 2] \n3×2 Array{Int64,2}:\n 1  -4\n 2   3\n 2   2\njulia> q,r = qr_by_householder_reflector(A)\n([0.33333333333333337 -0.9333333333333336 -0.1333333333333333; 0.6666666666666666 0.3333333333333332 -0.6666666666666667; 0.6666666666666666 0.13333333333333347 0.7333333333333334], [3.0 1.9999999999999998; 0.0 4.999999999999999; 0.0 0.0])\njulia> q\n3×3 Array{Float64,2}:\n 0.333333  -0.933333  -0.133333\n 0.666667   0.333333  -0.666667\n 0.666667   0.133333   0.733333\njulia> r\n3×2 Array{Float64,2}:\n 3.0  2.0\n 0.0  5.0\n 0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/#求解n元方程-1","page":"目录","title":"求解n元方程","text":"","category":"section"},{"location":"numerical_analysis/equation_set/#","page":"目录","title":"目录","text":"CurrentModule = EquationSet","category":"page"},{"location":"numerical_analysis/equation_set/#Content-1","page":"目录","title":"Content","text":"","category":"section"},{"location":"numerical_analysis/equation_set/#","page":"目录","title":"目录","text":"Pages = [\n    \"equation_set/gauss_elimination.md\",\n    \"equation_set/lu_factorization.md\",\n    \"equation_set/iteration_method.md\",\n    \"equation_set/methods_about_SPD_matrix.md\",\n    \"equation_set/nonlinear_equation_set.md\"\n]\nDepth = 3","category":"page"},{"location":"numerical_analysis/equation_set/#Index-1","page":"目录","title":"Index","text":"","category":"section"},{"location":"numerical_analysis/equation_set/#","page":"目录","title":"目录","text":"Pages   = map(file -> joinpath(\"equation_set\", file), readdir(\"equation_set\"))","category":"page"},{"location":"numerical_analysis/equation_solving/newton_method/#牛顿方法-1","page":"牛顿方法","title":"牛顿方法","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/newton_method/#","page":"牛顿方法","title":"牛顿方法","text":"CurrentModule = EquationSolving","category":"page"},{"location":"numerical_analysis/equation_solving/newton_method/#","page":"牛顿方法","title":"牛顿方法","text":"Pages   = [\"newton_method.md\"]","category":"page"},{"location":"numerical_analysis/equation_solving/newton_method/#牛顿拉普森方法-1","page":"牛顿方法","title":"牛顿拉普森方法","text":"","category":"section"},{"location":"numerical_analysis/equation_solving/newton_method/#","page":"牛顿方法","title":"牛顿方法","text":"Modules = [EquationSolving]\nFilter = f -> nameof(f) == :newton_raphson_method","category":"page"},{"location":"numerical_analysis/equation_solving/newton_method/#EquationSolving.newton_raphson_method","page":"牛顿方法","title":"EquationSolving.newton_raphson_method","text":"牛顿拉普森方法\n\nnewton_raphson_method(f, df, x_0, k, m=1)\n\n牛顿拉普森迭代法计算方程解\n\n牛顿拉普森方法迭代公式\n\nbeginaligned x_0 = 初始估计  x_i+1 = x_i - frac f(x_i)f(x_i)(i=0123) endaligned\n\nArguments\n\nf: f(x)函数\ndf: f(x)的导函数\nx_0: 初始估计值\nk: 迭代次数\nm: 重根树(default=1)\n\nExample\n\njulia> newton_raphson_method(x->x^3 +x -1, x->3x^2 +1, -0.7, 20)\n0.6823278038280193\n\n\n\n\n\n","category":"function"},{"location":"#数值分析(Julia语言描述)-1","page":"总目录","title":"数值分析(Julia语言描述)","text":"","category":"section"},{"location":"#求解一元方程-1","page":"总目录","title":"求解一元方程","text":"","category":"section"},{"location":"#","page":"总目录","title":"总目录","text":"Pages = [\n    \"numerical_analysis/equation_solving/bisect.md\",\n    \"numerical_analysis/equation_solving/fixed_point_iteration.md\",\n    \"numerical_analysis/equation_solving/newton_method.md\",\n    \"numerical_analysis/equation_solving/secant.md\",\n]\nDepth = 3","category":"page"},{"location":"#求解n元方程-1","page":"总目录","title":"求解n元方程","text":"","category":"section"},{"location":"#","page":"总目录","title":"总目录","text":"Pages = [\n    \"numerical_analysis/equation_set/gauss_elimination.md\",\n    \"numerical_analysis/equation_set/lu_factorization.md\",\n    \"numerical_analysis/equation_set/iteration_method.md\",\n    \"numerical_analysis/equation_set/methods_about_SPD_matrix.md\",\n    \"numerical_analysis/equation_set/nonlinear_equation_set.md\"\n]\nDepth = 3","category":"page"},{"location":"#插值多项式-1","page":"总目录","title":"插值多项式","text":"","category":"section"},{"location":"#","page":"总目录","title":"总目录","text":"Pages = [\n    \"numerical_analysis/interpolation_polynomial/newton_difference_quotient.md\",\n    \"numerical_analysis/interpolation_polynomial/error_and_runge_phenomenon.md\",\n    \"numerical_analysis/interpolation_polynomial/chebyshev_interpolation.md\",\n    \"numerical_analysis/interpolation_polynomial/cubic_spline.md\",\n    \"numerical_analysis/interpolation_polynomial/bezier_curve.md\",\n]\nDepth = 3","category":"page"},{"location":"#最小二乘-1","page":"总目录","title":"最小二乘","text":"","category":"section"},{"location":"#","page":"总目录","title":"总目录","text":"Pages = [\n    \"numerical_analysis/least_square/normal_equation.md\",\n    \"numerical_analysis/least_square/gram_schmidt_orthogon.md\",\n    \"numerical_analysis/least_square/least_square_and_qr.md\",\n    \"numerical_analysis/least_square/householder_reflector.md\",\n    \"numerical_analysis/least_square/gmres.md\",\n    \"numerical_analysis/least_square/nolinear_least_square.md\"\n]\nDepth = 3","category":"page"},{"location":"#模块索引-1","page":"总目录","title":"模块索引","text":"","category":"section"},{"location":"#","page":"总目录","title":"总目录","text":"","category":"page"},{"location":"numerical_analysis/least_square/least_square_and_qr/#最小二乘与QR分解-1","page":"最小二乘与QR分解","title":"最小二乘与QR分解","text":"","category":"section"},{"location":"numerical_analysis/least_square/least_square_and_qr/#","page":"最小二乘与QR分解","title":"最小二乘与QR分解","text":"CurrentModule = LeastSquare","category":"page"},{"location":"numerical_analysis/least_square/least_square_and_qr/#","page":"最小二乘与QR分解","title":"最小二乘与QR分解","text":"Pages   = [\"least_square_and_qr.md\"]","category":"page"},{"location":"numerical_analysis/least_square/least_square_and_qr/#不完全的QR分解-1","page":"最小二乘与QR分解","title":"不完全的QR分解","text":"","category":"section"},{"location":"numerical_analysis/least_square/least_square_and_qr/#","page":"最小二乘与QR分解","title":"最小二乘与QR分解","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :incomplete_qr","category":"page"},{"location":"numerical_analysis/least_square/least_square_and_qr/#LeastSquare.incomplete_qr-Tuple{Any,Any,Any}","page":"最小二乘与QR分解","title":"LeastSquare.incomplete_qr","text":"不完全的QR分解\n\nincomplete_qr(A, m, n)\n\n将格拉姆-施密特的正交过程写成矩阵形式，也就是将得到的所有单位向量作为矩阵Q的列向量，将每次正交的余项放入R矩阵右上角，具体如下：\n\n令r_jj = Vert y_j Vert_2, r_ij = q^T_ia_j\n\nqquad beginaligned a_1 = r_11q_1  a_2 = r_12q_1 + r_22q_2 endaligned\n\n更一般地：\n\nqquad a_j = r_1jq_1 +  + r_j-1jq_j-1 + r_jjq_j\n\nA = QR\n\nA是mtimes n矩阵, Q是mtimes n矩阵, R是ntimes n上三角方阵\n\n因为只有n个m维单位向量，无法张成出R^m空间，所以称之为不完全的QR分解\n\nExample\n\njulia> A = [1 -4; 2 3; 2 2]\n3×2 Array{Int64,2}:\n 1  -4\n 2   3\n 2   2\njulia> q,r = incomplete_qr(A, 3, 2)\n3×2 Array{Float64,2}:\n 0.3333  -0.9333\n 0.6667   0.3333\n 0.6667   0.1333\n2×2 Array{Float64,2}:\n 3.0  2.0\n 0.0  5.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/least_square_and_qr/#完全QR分解-1","page":"最小二乘与QR分解","title":"完全QR分解","text":"","category":"section"},{"location":"numerical_analysis/least_square/least_square_and_qr/#","page":"最小二乘与QR分解","title":"最小二乘与QR分解","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :complete_qr","category":"page"},{"location":"numerical_analysis/least_square/least_square_and_qr/#LeastSquare.complete_qr-Tuple{Any,Any,Any}","page":"最小二乘与QR分解","title":"LeastSquare.complete_qr","text":"完全QR分解\n\ncomplete_qr(A, m, n)\n\nA = QR\n\nA是mtimes n矩阵, Q是mtimes m正交方阵, R是mtimes n上三角矩阵\n\n为了实现完全QR分解，当nm时，需要在A中加上额外的m-n个向量(也是线性无关的)，从而使得Q可以张成R^m\n\n注意：使用格拉姆-施密特方法对mtimes m矩阵做QR分解，计算次数比LU分解的三倍还多，此外还有大约相同数量的加法\n\nExample\n\njulia> A = [1 -4; 2 3; 2 2]\n3×2 Array{Int64,2}:\n 1  -4\n 2   3\n 2   2\njulia> A = hcat(A, [1;0;0])    # 增加额外的线性无关向量\n3×3 Array{Int64,2}:\n 1  -4  1\n 2   3  0\n 2   2  0\njulia> q,r = complete_qr(A, 3, 2)\n3×3 Array{Float64,2}:\n 0.3333  -0.9333   0.1333\n 0.6667   0.3333   0.6667\n 0.6667   0.1333  -0.7333\n3×2 Array{Float64,2}:\n 3.0  2.0\n 0.0  5.0\n 0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/least_square/least_square_and_qr/#通过QR分解实现最小二乘-1","page":"最小二乘与QR分解","title":"通过QR分解实现最小二乘","text":"","category":"section"},{"location":"numerical_analysis/least_square/least_square_and_qr/#","page":"最小二乘与QR分解","title":"最小二乘与QR分解","text":"Modules = [LeastSquare]\nFilter = f -> nameof(f) == :least_square_by_complete_qr","category":"page"},{"location":"numerical_analysis/least_square/least_square_and_qr/#LeastSquare.least_square_by_complete_qr-Tuple{Any,Any,Any}","page":"最小二乘与QR分解","title":"LeastSquare.least_square_by_complete_qr","text":"通过QR分解实现最小二乘\n\nleast_square_by_complete_qr(A, b, x_0)\n\nA是mtimes n矩阵，求解x:\n\nAx = b\n\n找出完全QR分解：A=QR\n\n令：\n\nwidehatR= R的上ntimes n子矩阵\nwidehatd = d = Q^Tb的上n个元素\n\n求解Roverlinex = Q^Tb得到最小二乘解overlinex\n\nExample\n\njulia> A = [1 -4; 2 3; 2 2]\n3×2 Array{Int64,2}:\n 1  -4\n 2   3\n 2   2\n\njulia> A = hcat(A, [1;0;0])    # 增加额外的向量\n3×3 Array{Int64,2}:\n 1  -4  1\n 2   3  0\n 2   2  0\n\njulia> b = [-3;15;9]\n3-element Array{Int64,1}:\n -3\n 15\n  9\n\njulia> least_square_by_complete_qr(A, b, [1.0;1.0])\n2-element Array{Float64,1}:\n 3.8\n 1.8\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#非线性方程组-1","page":"非线性方程组","title":"非线性方程组","text":"","category":"section"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"CurrentModule = EquationSet","category":"page"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"Pages   = [\"nonlinear_equation_set.md\"]","category":"page"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#多变量牛顿法-1","page":"非线性方程组","title":"多变量牛顿法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :mult_newton_method","category":"page"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#EquationSet.mult_newton_method-NTuple{4,Any}","page":"非线性方程组","title":"EquationSet.mult_newton_method","text":"多变量牛顿方法\n\nmult_newton_method(f, df, x_0, k)\n\n多变量牛顿方法是由单变量牛顿方法推演而来。将单变量情况下的导函数f，定义为向量值函数F的雅可比矩阵。\n\nvec x=(uvw)\n\nF(x) = 0\n\n即 F(x) = left  beginmatrix f_1(x)  f_2(x)  f_3(x)   endmatrix right  = left  beginmatrix f_1(u v w)  f_2(u v w)  f_3(u v w)   endmatrix right  = 0\n\n雅可比矩阵DF(x)\n\nDF(x) = left  beginmatrix fracpartial f_1partial u space fracpartial f_1partial v space fracpartial f_1partial w space   fracpartial f_2partial u space fracpartial f_2partial v space fracpartial f_2partial w space   fracpartial f_3partial u space fracpartial f_3partial v space fracpartial f_3partial w space    endmatrix right \n\n令x=r是根，x_0是当前近似估计，根据泰勒一级展开，忽略二次余项\n\nbeginaligned 0 = F(r) approx F(x_0) + DF(x_0)cdot (r-x_0)  -DF(x_0)^-1F(x_0) approx r-x_0 endaligned\n\n多变量牛顿方法迭代公式：\n\nbeginaligned x_0 = 初始估计  x_k+1 = x_k- (DF(x_k))^-1F(x_k) space  space k=012 endaligned\n\n由于计算矩阵逆的代价通常较大，令s是DF(x_k)s = F(x_k)的解，然后在每步中使用高斯消去代替计算矩阵的逆，减少运算次数\n\nbeginaligned DF(x_k)s = F(x_k)  x_k+1 = x_k - s endaligned\n\nExample\n\n# F = [(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)]\n# DF = [(u,v)->(-3*u^2) (u,v)->(1); (u,v)->(2u) (u,v)->(2v)]\n# x_0 = [1, 2]\njulia> mult_newton_method([(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)],  [(u,v)->(-3*u^2) (u,v)->(1); (u,v)->(2u) (u,v)->(2v)], [1, 2], 10)\n2×1 Array{Float64,2}:\n 0.826031357654187\n 0.5636241621612585\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#Broyden-方法-1","page":"非线性方程组","title":"Broyden 方法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :broyden","category":"page"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#EquationSet.broyden-NTuple{4,Any}","page":"非线性方程组","title":"EquationSet.broyden","text":"Broyden方法\n\nbroyden(F, A_0, x_0, k)\n\n当无法得到雅可比矩阵DF时，Broyden方法通常被认为是一种次优的方法。\n\n将设A_i是第i步可以得到的雅可比矩阵的最优近似，并被用于：\n\nx_k+1 = x_k - A^-1_iF(x_i)\n\n为了根据A_i更新得到A_i+1。首先注意到雅可比矩阵满足：\n\nbeginaligned A_i+1delta_i+1 = Delta_i+1  delta_i+1 = x_i+1 - x_i  Delta_i+1 = F(x_i+1) - F(x_i) endaligned\n\n要求所有满足delta^T_i+1omega = 0的omega：\n\nA_i+1omega = A_i omega\n\n则同时满足上述条件的矩阵如下:\n\nA_i+1 = A_i + frac(Delta_i+1 - A_idelta_i)delta^T_i+1delta^T_i+1delta_i+1\n\nExample\n\n# F = [(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)]\n# A_0 = Matrix{Float64}(I, 2, 2)\n# x_0 = Float64[1, 2]\njulia> using LinearAlgebra\n\njulia> broyden([(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)],  Matrix{Float64}(I, 2, 2), Float64[1, 2], 20)\n2×1 Array{Float64,2}:\n 0.8260271593976959\n 0.5635461739578368\n\n\n\n\n\n","category":"method"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#Broyden-方法-2","page":"非线性方程组","title":"BroydenⅡ 方法","text":"","category":"section"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#","page":"非线性方程组","title":"非线性方程组","text":"Modules = [EquationSet]\nFilter = f -> nameof(f) == :broyden2","category":"page"},{"location":"numerical_analysis/equation_set/nonlinear_equation_set/#EquationSet.broyden2-NTuple{4,Any}","page":"非线性方程组","title":"EquationSet.broyden2","text":"BroydenⅡ 方法\n\nbroyden2(F, B_0, x_0, k)\n\nBroyden的第二种方式避免相对代价较大的矩阵求解步骤。相比近似DF导数，同样我们可以近似DF的逆\n\n基于B_i = A^-1_i，我们希望得到：\n\ndelta_i+1 = B_i+1Delta_i+1\n\n同样为了根据B_i更新得到B_i+1。首先注意到雅可比矩阵满足：\n\nbeginaligned A_i+1delta_i+1 = Delta_i+1  delta_i+1 = x_i+1 - x_i  Delta_i+1 = F(x_i+1) - F(x_i) endaligned\n\n要求所有满足delta^T_i+1omega = 0的omega：\n\nA_i+1omega = A_i omega\n\n或者：\n\nB_i+1A_iomega = omega\n\n则同时满足上述条件的矩阵如下:\n\nB_i+1 = B_i + frac(delta_i+1 - B_iDelta_i)delta^T_i+1B_idelta^T_i+1B_iDelta_i+1\n\n不再需要进行矩阵求解的迭代公式：\n\nx_i+1 = x_i - B_iF(x_i)\n\nExample\n\n# F = [(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)]\n# B_0 = Matrix{Float64}(I, 2, 2)\n# x_0 = Float64[1, 2]\njulia> using LinearAlgebra\n\njulia> broyden2([(u,v)->(v-u^3); (u,v)->(u^2 + v^2 -1)],  Matrix{Float64}(I, 2, 2), Float64[1, 2], 50)\n2-element Array{Float64,1}:\n 0.8260313576541872\n 0.5636241621612585\n\n\n\n\n\n","category":"method"}]
}
