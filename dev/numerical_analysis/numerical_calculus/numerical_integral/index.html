<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>数值积分 · 数值分析(Julia语言描述)</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/logo.png" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="数值分析(Julia语言描述) logo"/></a><div class="docs-package-name"><span class="docs-autofit">数值分析(Julia语言描述)</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">总目录</a></li><li><span class="tocitem">求解一元方程</span><ul><li><a class="tocitem" href="../../equation_solving/">目录</a></li><li><a class="tocitem" href="../../equation_solving/bisect/">二分法</a></li><li><a class="tocitem" href="../../equation_solving/fixed_point_iteration/">不动点迭代法</a></li><li><a class="tocitem" href="../../equation_solving/newton_method/">牛顿方法</a></li><li><a class="tocitem" href="../../equation_solving/secant/">割线方法</a></li></ul></li><li><span class="tocitem">求解n元方程组</span><ul><li><a class="tocitem" href="../../equation_set/">目录</a></li><li><a class="tocitem" href="../../equation_set/gauss_elimination/">高斯消去法</a></li><li><a class="tocitem" href="../../equation_set/lu_factorization/">LU分解</a></li><li><a class="tocitem" href="../../equation_set/iteration_method/">迭代方法</a></li><li><a class="tocitem" href="../../equation_set/methods_about_SPD_matrix/">用于对称正定矩阵的方法</a></li><li><a class="tocitem" href="../../equation_set/nonlinear_equation_set/">非线性方程组</a></li></ul></li><li><span class="tocitem">插值多项式</span><ul><li><a class="tocitem" href="../../interpolation_polynomial/">目录</a></li><li><a class="tocitem" href="../../interpolation_polynomial/newton_difference_quotient/">牛顿差商</a></li><li><a class="tocitem" href="../../interpolation_polynomial/error_and_runge_phenomenon/">插值误差和龙格现象</a></li><li><a class="tocitem" href="../../interpolation_polynomial/chebyshev_interpolation/">切比雪夫插值</a></li><li><a class="tocitem" href="../../interpolation_polynomial/cubic_spline/">三次样条插值</a></li><li><a class="tocitem" href="../../interpolation_polynomial/bezier_curve/">贝塞尔曲线</a></li></ul></li><li><span class="tocitem">最小二乘</span><ul><li><a class="tocitem" href="../../least_square/">目录</a></li><li><a class="tocitem" href="../../least_square/normal_equation/">最小二乘与法线方程</a></li><li><a class="tocitem" href="../../least_square/gram_schmidt_orthogon/">格拉姆-施密特正交</a></li><li><a class="tocitem" href="../../least_square/least_square_and_qr/">最小二乘与QR分解</a></li><li><a class="tocitem" href="../../least_square/householder_reflector/">豪斯霍尔德反射方法</a></li><li><a class="tocitem" href="../../least_square/gmres/">广义最小余项方法(GMRES)</a></li><li><a class="tocitem" href="../../least_square/nolinear_least_square/">非线性最小二乘</a></li></ul></li><li><span class="tocitem">数值微分与积分</span><ul><li><a class="tocitem" href="../">目录</a></li><li><a class="tocitem" href="../numerical_differential/">数值微分</a></li><li class="is-active"><a class="tocitem" href>数值积分</a><ul class="internal"><li><a class="tocitem" href="#闭牛顿-科特斯方法-1"><span>闭牛顿-科特斯方法</span></a></li><li><a class="tocitem" href="#开牛顿-科特斯方法-1"><span>开牛顿-科特斯方法</span></a></li><li><a class="tocitem" href="#Romberg-积分-1"><span>Romberg 积分</span></a></li><li><a class="tocitem" href="#自适应积分-1"><span>自适应积分</span></a></li></ul></li></ul></li><li><span class="tocitem">常微分方程</span><ul><li><a class="tocitem" href="../../ordinary_differential_equation/">目录</a></li><li><a class="tocitem" href="../../ordinary_differential_equation/euler/">欧拉方法</a></li><li><a class="tocitem" href="../../ordinary_differential_equation/explicit_trap/">显示梯形方法(改进的欧拉方法)</a></li><li><a class="tocitem" href="../../ordinary_differential_equation/taylor_method/">泰勒方法</a></li><li><a class="tocitem" href="../../ordinary_differential_equation/equations/">常微分方程组</a></li><li><a class="tocitem" href="../../ordinary_differential_equation/the_pendulum/">计算机仿真: 钟摆模型</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">数值微分与积分</a></li><li class="is-active"><a href>数值积分</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>数值积分</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/luo-songtao/TheNumericalAnalysisInJulia/blob/master/docs/src/numerical_analysis/numerical_calculus/numerical_integral.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="数值积分-1"><a class="docs-heading-anchor" href="#数值积分-1">数值积分</a><a class="docs-heading-anchor-permalink" href="#数值积分-1" title="Permalink"></a></h1><ul><li><a href="#NumericalCalculus.middle_point_rule-NTuple{4,Any}"><code>NumericalCalculus.middle_point_rule</code></a></li><li><a href="#NumericalCalculus.romberg_integral-NTuple{4,Any}"><code>NumericalCalculus.romberg_integral</code></a></li><li><a href="#NumericalCalculus.simpson_adaptive_integral-NTuple{4,Any}"><code>NumericalCalculus.simpson_adaptive_integral</code></a></li><li><a href="#NumericalCalculus.simpson_rule-NTuple{4,Any}"><code>NumericalCalculus.simpson_rule</code></a></li><li><a href="#NumericalCalculus.trap_adaptive_integral-NTuple{4,Any}"><code>NumericalCalculus.trap_adaptive_integral</code></a></li><li><a href="#NumericalCalculus.trapezoidal_rule-NTuple{4,Any}"><code>NumericalCalculus.trapezoidal_rule</code></a></li></ul><h2 id="闭牛顿-科特斯方法-1"><a class="docs-heading-anchor" href="#闭牛顿-科特斯方法-1">闭牛顿-科特斯方法</a><a class="docs-heading-anchor-permalink" href="#闭牛顿-科特斯方法-1" title="Permalink"></a></h2><h3 id="(复合)梯形法则-1"><a class="docs-heading-anchor" href="#(复合)梯形法则-1">(复合)梯形法则</a><a class="docs-heading-anchor-permalink" href="#(复合)梯形法则-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NumericalCalculus.trapezoidal_rule-NTuple{4,Any}" href="#NumericalCalculus.trapezoidal_rule-NTuple{4,Any}"><code>NumericalCalculus.trapezoidal_rule</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>复合梯形法则</strong></p><pre><code class="language-none">trapezoidal_rule(f, a, b, m)</code></pre><p><strong>梯形法则</strong></p><p>梯形法则使用通过<span>$(x_0,f(x_0))和(x_1,f(x_1))$</span>的直线替换函数。</p><p>令<span>$f(x)$</span>是具有连续二阶导数的函数，定义在<span>$[x_0, x_1]$</span>上，使用拉格朗日公式，得到具有误差项的一阶插值多项式是:</p><div>\[f(x) = y_0\frac {x-x_1}{x_0-x_1} + y_1 \frac {x-x_0}{x_1-x_0} + \frac {(x-x_0)(x-x_1)}{2!}f&#39;&#39;(c_x) = P(x) + E(x)\]</div><p>则在区间<span>$[x_0, x_1]$</span>上：</p><div>\[\int_{x_0}^{x_1}f(x)dx = \int_{x_0}^{x_1}P(x)dx + \int_{x_0}^{x_1} E(x)dx\]</div><p>令<span>$h=x_1-x_0$</span></p><p><span>$\qquad \begin{aligned} \int_{x_0}^{x_1}P(x)dx &amp;= y_0\int_{x_0}^{x_1}\frac {x-x_1}{x_0-x_1} + y_1 \int_{x_0}^{x_1}\frac {x-x_0}{x_1-x_0} = \frac h2 (y_0+y_1) \\ \int_{x_0}^{x_1}E(x)dx &amp;= \frac 1{2!} \int_{x_0}^{x_1}(x-x_0)(x-x_1)f&#39;&#39;(c)dx = -\frac {h^3}{12}f&#39;&#39;(c) \end{aligned}$</span></p><p><strong>梯形法则公式</strong>：</p><div>\[\int_{x_0}^{x_1}f(x)dx = \frac h2 (y_0+y_1) - \frac {h^3}{12}f&#39;&#39;(c)\]</div><p>其中<span>$h=x_1-x_0$</span>,<span>$c$</span>在<span>$x_0$</span>和<span>$x_1$</span>之间</p><p><strong>复合梯形法则</strong></p><p>梯形法则局限在单一区间上操作，由于积分在区间的所有子区间上具有可加性，我们可以将区间分为多个小区间分别处理，这样的策略被称为复合数值积分</p><div>\[\int_{x_i}^{x_{i+1}}f(x)dx = \frac h2 (f(x_i)+f(x_{i+1})) - \frac {h^3}{12}f&#39;&#39;(c_i)\]</div><p><strong>复合梯形法则公式</strong>:</p><div>\[\int_{a}^{b}f(x)dx = \frac h2 (y_0+y_m + 2\sum_{i=1}^{m-1}y_i) - \frac {(b-a)h^2}{12}f&#39;&#39;(c)\]</div><p>其中 <span>$h=\frac {(b-a)}{m}$</span>,c在a和b之间</p><p>误差项根据中值定理，改写为：</p><div>\[\sum_{i=0}^{m-1}\frac {h^3}{12}f&#39;&#39;(c_i) = \frac {h^3}{12}mf&#39;&#39;(c) = \frac {(b-a)h^2}{12}f&#39;&#39;(c)\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; trapezoidal_rule(x-&gt; log(exp(1), x), 1, 2, 1)   # ln(x)  [1,2]   m=1
0.34657359027997264
julia&gt; trapezoidal_rule(x-&gt; log(exp(1), x), 1, 2, 10)   # ln(x)  [1,2]  m=10
0.3216925481285146</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumericalAnalysisInJulia/blob/708478d6896d434a1c6a872c2f992f27075e2616/src/numerical_calculus/trapezoidal_rule.jl#L1-L59">source</a></section></article><h3 id="(复合)辛普森法则-1"><a class="docs-heading-anchor" href="#(复合)辛普森法则-1">(复合)辛普森法则</a><a class="docs-heading-anchor-permalink" href="#(复合)辛普森法则-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NumericalCalculus.simpson_rule-NTuple{4,Any}" href="#NumericalCalculus.simpson_rule-NTuple{4,Any}"><code>NumericalCalculus.simpson_rule</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>复合辛普森法则</strong></p><pre><code class="language-none">simpson_rule(f, a, b, m)</code></pre><p><strong>辛普森法则</strong></p><p>辛普森法则使用通过三点的二次函数替换函数。</p><p>令<span>$f(x)$</span>是具有连续二阶导数的函数，定义在<span>$[x_0, x_2]$</span>上，使用拉格朗日公式，得到具有误差项的二阶插值多项式是:</p><div>\[f(x) = y_0\frac {(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)} + y_1 \frac {(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)} + y_2 \frac {(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)} \\ 
+ \frac {(x-x_0)(x-x_1)(x-x_2)}{3!}f&#39;&#39;&#39;(c_x) = P(x) + E(x)\]</div><p>则在区间<span>$[x_0, x_2]$</span>上：</p><div>\[\int_{x_0}^{x_2}f(x)dx = \int_{x_0}^{x_2}P(x)dx + \int_{x_0}^{x_2} E(x)dx\]</div><p>令<span>$h=x_2-x_1=x_1-x_0$</span></p><p><span>$\qquad \begin{aligned} \int_{x_0}^{x_2}P(x)dx = y_0\int_{x_0}^{x_2}\frac {(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}dx + y_1 \int_{x_0}^{x_2}\frac {(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}dx+ \\  y_2 \int_{x_0}^{x_2} \frac {(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}dx = \frac h3 (y_0 + 4y_1 + y_2) \end{aligned}$</span></p><p>如果<span>$f^{(4)}(x)$</span>`存在并连续，那么误差为:</p><div>\[\int_{x_0}^{x_2} E(x)dx = -\frac {h^5}{90}f^{(4)}(c)\]</div><p><strong>辛普森法则</strong>：</p><div>\[\int_{x_0}^{x_2}f(x)dx = \frac h3 (y_0 + 4y_1 + y_2)-\frac {h^5}{90}f^{(4)}(c)\]</div><p>其中<span>$h=x_2-x_0=x_1-x_0$</span>,<span>$c$</span>在<span>$x_0$</span>和<span>$x_2$</span>之间</p><p><strong>复合辛普森法则</strong></p><p>同样辛普森法则局限在单一区间上操作，由于积分在区间的所有子区间上具有可加性，我们可以将区间分为多个小区间分别处理。但复合辛普森法则是按照每个长2h的子区间</p><div>\[\int_{x_2i}^{x_{2i+2}}f(x)dx = \frac h3 (f(x_{2i}) + 4f(x_{2i+1}) + f(x_{2i+2})) - \frac {h^5}{90}f^{(4)}(c_i)\]</div><p><strong>复合辛普森法则公式</strong>:     simpson_rule(f, a, b, m)</p><div>\[\int_{a}^{b}f(x)dx =  \frac h3 (y_0 + y_{2m} + 4\sum_{i=1}^m y_{2i+1} + 2\sum_{i=1}^{m-1}y_{2i}) - \frac {(b-a)h^4}{180}f^{(4)}(c)\]</div><p>其中 <span>$h=\frac {(b-a)}{m}$</span>,c在a和b之间</p><p>同样对于误差项根据中值定理，改写为(<span>$m = \frac {b-a}{2h}$</span>)：</p><div>\[\sum_{i=0}^{m-1}\frac {h^5}{90}f^{(4)}(c_i) = \frac {h^5}{90}mf^{(4)}(c) = \frac {(b-a)h^4}{180}f^{(4)}(c)\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; simpson_rule(x-&gt; log(exp(1), x), 1, 2, 4)   # ln(x)  [1,2]   m=4    误差很小了
0.3862920434663129</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumericalAnalysisInJulia/blob/708478d6896d434a1c6a872c2f992f27075e2616/src/numerical_calculus/simpson_rule.jl#L1-L63">source</a></section></article><h2 id="开牛顿-科特斯方法-1"><a class="docs-heading-anchor" href="#开牛顿-科特斯方法-1">开牛顿-科特斯方法</a><a class="docs-heading-anchor-permalink" href="#开牛顿-科特斯方法-1" title="Permalink"></a></h2><h3 id="(复合)中点法则-1"><a class="docs-heading-anchor" href="#(复合)中点法则-1">(复合)中点法则</a><a class="docs-heading-anchor-permalink" href="#(复合)中点法则-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NumericalCalculus.middle_point_rule-NTuple{4,Any}" href="#NumericalCalculus.middle_point_rule-NTuple{4,Any}"><code>NumericalCalculus.middle_point_rule</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>复合中点法则</strong></p><p>梯形法则和辛普森法则都被称为闭牛顿-科特斯方法，因为它们都是在闭区间上的，因此如果是开区间上，可以使用中点法则</p><p>中点法则其实只用了一个点来进行插值，且它相当于一条平行于x轴的直线，因此它的一阶导数为0</p><p>同样对于函数f，二阶导数在给定区间上连续。那么f在区间中点<span>$\omega = x_0+h/2，h=x_1-x_0$</span>的一阶Taylor展开：</p><div>\[f(x) = f(\omega) + f(x-\omega)f&#39;(\omega) +\frac 12 (x-\omega)^2 f&#39;&#39;(c_x)\]</div><p>队上式两则进行积分可得<strong>中点法则公式</strong>：</p><div>\[\int_{x_0}^{x_1} f(x)dx = (x_1-x_0)f(\omega) + 0 + \frac 12 \int_{x_0}^{x_1}f&#39;&#39;(c_x)(x-\omega)^2dx = hf(\omega) + \frac {h^3}{24}f&#39;&#39;(c)\]</div><p><strong>复合中点法则公式</strong></p><div>\[\int_{a}^{b}f(x)dx = h\sum_{i=1}^{m}f(\omega_i) + \frac {b-a}{24}h^2f&#39;&#39;(c)\]</div><p>其中<span>$h=\frac {b-a}{m}$</span></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; middle_point_rule(x-&gt;sin(x)/x, 0, 1, 10)
0.9462085788431455</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumericalAnalysisInJulia/blob/708478d6896d434a1c6a872c2f992f27075e2616/src/numerical_calculus/middle_point_rule.jl#L1-L29">source</a></section></article><h2 id="Romberg-积分-1"><a class="docs-heading-anchor" href="#Romberg-积分-1">Romberg 积分</a><a class="docs-heading-anchor-permalink" href="#Romberg-积分-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NumericalCalculus.romberg_integral-NTuple{4,Any}" href="#NumericalCalculus.romberg_integral-NTuple{4,Any}"><code>NumericalCalculus.romberg_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Romberg Integral</strong></p><pre><code class="language-none">romberg_integral(f, a, b, n)</code></pre><p>Romberg Integral是对复合梯形法则应用外推的结果。复合梯形法则是关于h的二阶法则，使用外推至少可以得到三阶的法则。</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; romberg_integral(x-&gt;log(exp(1), x), 1, 2, 4)
4×4 Array{Float64,2}:
 0.346574  0.0       0.0       0.0     
 0.376019  0.385835  0.0       0.0     
 0.3837    0.38626   0.386288  0.0     
 0.385644  0.386292  0.386294  0.386294</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumericalAnalysisInJulia/blob/708478d6896d434a1c6a872c2f992f27075e2616/src/numerical_calculus/romberg_integral.jl#L1-L15">source</a></section></article><h2 id="自适应积分-1"><a class="docs-heading-anchor" href="#自适应积分-1">自适应积分</a><a class="docs-heading-anchor-permalink" href="#自适应积分-1" title="Permalink"></a></h2><h3 id="自适应梯形法则积分-1"><a class="docs-heading-anchor" href="#自适应梯形法则积分-1">自适应梯形法则积分</a><a class="docs-heading-anchor-permalink" href="#自适应梯形法则积分-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NumericalCalculus.trap_adaptive_integral-NTuple{4,Any}" href="#NumericalCalculus.trap_adaptive_integral-NTuple{4,Any}"><code>NumericalCalculus.trap_adaptive_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>自适应积分</strong></p><p>虽然对于复合的梯形法则和复合的辛普森法则等积分近似方法，可以得到对应的误差公式，但是这些误差公式都是依赖于更高阶的导数进行求取。 因此如果要想直接使用这些公式计算，用于满足给定容差对应的h值通常是比较困难的。</p><p>另外这些方法都是使用的相同的步长，，而函数通常啃根在定义域的某些部分的变化非常剧烈，而在其他部分变化缓慢，因此相同的步长明显是太适合整个区间。</p><p>因此这里使用积分误差公式，可以在运算中推出一个标准，其步长对于特定的子空间适合，这种方法称为自适应积分。</p><p><strong>自适应梯形法则公式</strong></p><pre><code class="language-none">trap_adaptive_integral(f, a, b, tol)</code></pre><p>在区间[a,b]上的梯形法则<span>$S_{[a,b]}$</span>满足：</p><div>\[\int_a^bf(x)dx = S_{[a,b]} - h^3\frac {f&#39;&#39;(c_0)}{12}\]</div><p>我们对区间[a,b]进行二分为[a,c],[c,b]后(c为中点)可得：</p><div>\[\int_a^bf(x)dx = S_{[a,c]} - \frac {h^3}{8} \frac {f&#39;&#39;(c_1)}{12} + S_{[c,b]} - \frac {h^3}{8} \frac {f&#39;&#39;(c_2)}{12} = S_{[a,c]} + S_{[c,b]} - \frac {h^3}{4} \frac {f&#39;&#39;(c_3)}{12}\]</div><p>将上面的两式相减得到:</p><div>\[S_{[a,b]} - (S_{[a,c]} + S_{[c,b]}) = - \frac {h^3}{4} \frac {f&#39;&#39;(c_3)}{12} + h^3\frac {f&#39;&#39;(c_0)}{12} \approx \frac {3}{4}h^3 \frac {f&#39;&#39;(c_0)}{12}\]</div><p>这里我们近似<span>$f&#39;&#39;(c_0) \approx f&#39;&#39;(c_3)$</span></p><p>因此可以看到<span>$S_{[a,b]} - (S_{[a,c]} + S_{[c,b]})$</span>的误差，近似是<span>$S_{[a,c]} + S_{[c,b]}$</span>的误差的三倍</p><p>因此那么可以通过检查<span>$S_{[a,b]} - (S_{[a,c]} + S_{[c,b]})$</span>的值是小于给定容差的三倍，来作为一种近似方式，判断误差是否近似低于给定容差</p><p>如果没有满足，那么就对剩下的区间再进行递归形式划分，然后求解</p><p><strong>Example</strong></p><p>使用自适应梯形积分近似计算<span>$\int_{-1}^1 (1+\sin e^{3x})dx$</span></p><pre><code class="language-julia-repl">julia&gt; trap_adaptive_integral(x -&gt; 1 + sin(exp(1)^(3x)), -1, 1, 0.005)
2.501859632312862
julia&gt; trap_adaptive_integral(x -&gt; 1 + sin(exp(1)^(3x)), -1, 1, 0.0005)
2.5009058956107495</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumericalAnalysisInJulia/blob/708478d6896d434a1c6a872c2f992f27075e2616/src/numerical_calculus/adaptive_integral.jl#L1-L45">source</a></section></article><h3 id="自适应辛普森法则积分-1"><a class="docs-heading-anchor" href="#自适应辛普森法则积分-1">自适应辛普森法则积分</a><a class="docs-heading-anchor-permalink" href="#自适应辛普森法则积分-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NumericalCalculus.simpson_adaptive_integral-NTuple{4,Any}" href="#NumericalCalculus.simpson_adaptive_integral-NTuple{4,Any}"><code>NumericalCalculus.simpson_adaptive_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>自适应辛普森法则公式</strong></p><pre><code class="language-none">simpson_adaptive_integral(f, a, b, tol)</code></pre><p>在区间[a,b]上的梯形法则<span>$S_{[a,b]}$</span>满足：</p><div>\[\int_a^bf(x)dx = S_{[a,b]} - \frac {h^5}{90} f^{(4)}(c_0)\]</div><p>我们对区间[a,b]进行二分为[a,c],[c,b]后(c为中点)可得：</p><div>\[\int_a^bf(x)dx = S_{[a,c]} - \frac {h^5}{32} \frac {f^{(4)}(c_1)}{90} + S_{[c,b]} - \frac {h^5}{32} \frac {f^{(4)}(c_2)}{90} = S_{[a,c]} + S_{[c,b]} - \frac {h^5}{16} \frac {f^{(4)}(c_3)}{90}\]</div><p>将上面的两式相减得到:</p><div>\[S_{[a,b]} - (S_{[a,c]} + S_{[c,b]}) = \frac {h^5}{90} f^{(4)}(c_0) - \frac {h^5}{16} \frac {f^{(4)}(c_3)}{90} \approx \frac {15}{16} h^5 \frac {f^{(4)}(c_3)}{90}\]</div><p>这里我们近似<span>$f^{(4)}(c_0) \approx f^{(4)}(c_3)$</span></p><p>因此可以看到<span>$S_{[a,b]} - (S_{[a,c]} + S_{[c,b]})$</span>的误差，近似是<span>$S_{[a,c]} + S_{[c,b]}$</span>的误差的15倍，但通常，将15设置为10，显得更保守点</p><p><strong>Example</strong></p><p>使用自适应辛普森积分近似计算<span>$\int_{-1}^1 (1+\sin e^{3x})dx$</span></p><pre><code class="language-julia-repl">julia&gt; simpson_adaptive_integral(x -&gt; 1 + sin(exp(1)^(3x)), -1, 1, 0.005)
2.5002123674678263
julia&gt; simpson_adaptive_integral(x -&gt; 1 + sin(exp(1)^(3x)), -1, 1, 0.0005)
2.499918700559637</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/luo-songtao/TheNumericalAnalysisInJulia/blob/708478d6896d434a1c6a872c2f992f27075e2616/src/numerical_calculus/adaptive_integral.jl#L62-L93">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../numerical_differential/">« 数值微分</a><a class="docs-footer-nextpage" href="../../ordinary_differential_equation/">目录 »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 22 February 2020 07:03">Saturday 22 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
